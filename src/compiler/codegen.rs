use crate::compiler::ast::{BinaryOperator, Expression, Program, Statement, TopLevel};
use crate::compiler::symbol_table::{SymbolKind, SymbolTable};

pub struct CodeGenerator {
    symbol_table: SymbolTable, // We might need to clone or move the symbol table from Analyzer
    output: Vec<String>,
    ram_pointer: u16,
    label_counter: usize,
}

impl CodeGenerator {
    pub fn new(symbol_table: SymbolTable) -> Self {
        Self {
            symbol_table,
            output: Vec::new(),
            ram_pointer: 0x0000, // Zero Page start (or wherever we want to start)
            label_counter: 0,
        }
    }

    fn new_label(&mut self) -> String {
        self.label_counter += 1;
        format!("__L{}", self.label_counter)
    }

    pub fn generate(&mut self, program: &Program) -> Result<Vec<String>, String> {
        self.output.clear();
        self.output.push(".ORG $8000".to_string()); // Start of PRG ROM
        self.output.push("; Generated by SwissArmyNES".to_string());

        // Standard NES System Vectors (to be placed at $FFFA)
        // NMI, RESET, IRQ
        // We will generate a "Reset" routine that initializes the system and calls Main
        // NMI and IRQ will point to user defined handlers or RTI

        // Pass 1: Allocate variables
        self.allocate_memory(program)?;

        // Pass 2: Generate code
        self.generate_startup_routine()?;

        for decl in &program.declarations {
            self.generate_top_level(decl)?;
        }

        // Pass 3: Generate Vectors
        self.generate_vectors(program)?;

        Ok(self.output.clone())
    }

    fn generate_startup_routine(&mut self) -> Result<(), String> {
        self.output.push("Startup:".to_string());
        self.output
            .push("  SEI          ; Disable IRQs".to_string());
        self.output
            .push("  CLD          ; Disable Decimal Mode".to_string());
        self.output.push("  LDX #$40".to_string());
        self.output
            .push("  STX $4017    ; Disable APU frame IRQ".to_string());
        self.output.push("  LDX #$FF".to_string());
        self.output
            .push("  TXS          ; Set Stack Pointer to $FF".to_string());
        self.output.push("  INX          ; X = 0".to_string());
        self.output.push("  STX $2000    ; Disable NMI".to_string());
        self.output
            .push("  STX $2001    ; Disable Rendering".to_string());
        self.output
            .push("  STX $4010    ; Disable DMC IRQs".to_string());

        // Wait for VBLANK (1)
        self.output.push("vblankwait1:".to_string());
        self.output.push("  BIT $2002".to_string());
        self.output.push("  BPL vblankwait1".to_string());

        // Clear Memory (RAM)
        self.output.push("clrmem:".to_string());
        self.output.push("  LDA #$00".to_string());
        self.output.push("  STA $00,x".to_string());
        self.output.push("  STA $0100,x".to_string());
        self.output.push("  STA $0300,x".to_string());
        self.output.push("  STA $0400,x".to_string());
        self.output.push("  STA $0500,x".to_string());
        self.output.push("  STA $0600,x".to_string());
        self.output.push("  STA $0700,x".to_string());
        self.output.push("  LDA #$FE".to_string());
        self.output
            .push("  STA $0200,x ; Move sprites offscreen".to_string());
        self.output.push("  INX".to_string());
        self.output.push("  BNE clrmem".to_string());

        // Wait for VBLANK (2)
        self.output.push("vblankwait2:".to_string());
        self.output.push("  BIT $2002".to_string());
        self.output.push("  BPL vblankwait2".to_string());

        // Call Main if it exists
        // We assume Main exists and takes no parameters for now
        self.output.push("  JSR Main".to_string());

        // Infinite loop after Main returns
        self.output.push("forever:".to_string());
        self.output.push("  JMP forever".to_string());
        self.output.push("".to_string());

        Ok(())
    }

    fn generate_vectors(&mut self, program: &Program) -> Result<(), String> {
        self.output.push("".to_string());
        self.output.push(".ORG $FFFA".to_string());

        // Find NMI Handler
        let nmi_label = program.declarations.iter().find_map(|d| {
            if let TopLevel::Interrupt(name, _) = d {
                if name.to_uppercase() == "NMI" {
                    return Some(name.clone());
                }
            }
            None
        });

        // Find IRQ Handler
        let irq_label = program.declarations.iter().find_map(|d| {
            if let TopLevel::Interrupt(name, _) = d {
                if name.to_uppercase() == "IRQ" {
                    return Some(name.clone());
                }
            }
            None
        });

        // Emit Vectors
        // NMI
        if let Some(lbl) = &nmi_label {
            self.output.push(format!("VecNMI: WORD {}", lbl));
        } else {
            self.output.push("VecNMI: WORD $0000".to_string());
        }

        // RESET
        self.output.push("VecReset: WORD Startup".to_string());

        // IRQ
        if let Some(lbl) = &irq_label {
            self.output.push(format!("VecIRQ: WORD {}", lbl));
        } else {
            self.output.push("VecIRQ: WORD $0000".to_string());
        }

        self.output.push("".to_string()); // Ensure trailing newline

        Ok(())
    }

    fn allocate_memory(&mut self, program: &Program) -> Result<(), String> {
        // Simple allocation strategy: Linear allocation in Zero Page (0x00 - 0xFF)
        // or RAM (0x0200 - 0x07FF)

        // Reset pointer to start of user RAM (e.g., 0x0300 to avoid stack and system variables)
        // For 6502 NES, 0x00-0xFF is Zero Page (fast), 0x0100 is Stack. 0x0200 is OAM buffer usually.
        // Let's start at 0x0300 for global variables.
        self.ram_pointer = 0x0300;

        for decl in &program.declarations {
            if let TopLevel::Dim(name, _dtype) = decl {
                // Assign address
                // Update symbol table
                // We need to resolve the symbol first
                // The symbol table passed in `new` should already have these defined from Semantic Analysis
                // We just need to set the address.
                self.symbol_table.assign_address(name, self.ram_pointer)?;
                self.output
                    .push(format!("; {} @ ${:04X}", name, self.ram_pointer));

                // Increment pointer (assume 1 byte for now for everything)
                // TODO: Handle WORD (2 bytes)
                self.ram_pointer += 1;
            }
        }
        Ok(())
    }

    fn generate_top_level(&mut self, decl: &TopLevel) -> Result<(), String> {
        match decl {
            TopLevel::Sub(name, _params, body) => {
                self.output.push(format!("{}:", name));
                self.generate_block(body)?;
                self.output.push("  RTS".to_string());
                self.output.push("".to_string()); // Newline for readability
            }
            TopLevel::Interrupt(name, body) => {
                self.output.push(format!("{}:", name));
                self.generate_block(body)?;
                self.output.push("  RTI".to_string());
                self.output.push("".to_string());
            }
            TopLevel::Const(_, _) => {
                // Constants are inlined usually, or we could emit equates?
                // For now, resolved at compile time if possible.
            }
            TopLevel::Dim(_, _) => {
                // Handled in allocation pass
            }
            TopLevel::Asm(lines) => {
                for line in lines {
                    self.output.push(format!("  {}", line));
                }
            }
        }
        Ok(())
    }

    fn generate_block(&mut self, statements: &[Statement]) -> Result<(), String> {
        for stmt in statements {
            self.generate_statement(stmt)?;
        }
        Ok(())
    }

    fn generate_statement(&mut self, stmt: &Statement) -> Result<(), String> {
        match stmt {
            Statement::Let(name, expr) => {
                // 1. Evaluate expression -> result in A (Accumulator)
                self.generate_expression(expr)?;

                // 2. Store A into variable address
                if let Some(sym) = self.symbol_table.resolve(name) {
                    if let Some(addr) = sym.address {
                        self.output.push(format!("  STA ${:04X} ; {}", addr, name));
                    } else {
                        // If it's a local variable (allocated on stack or temp zp), handling is more complex.
                        // For Phase 7, maybe we assume only globals or we allocate locals too?
                        return Err(format!(
                            "Variable '{}' has no address assigned (Locals not supported yet)",
                            name
                        ));
                    }
                } else {
                    return Err(format!("Undefined variable '{}'", name));
                }
            }
            Statement::Asm(lines) => {
                for line in lines {
                    self.output.push(format!("  {}", line));
                }
            }
            Statement::Poke(addr_expr, val_expr) => {
                // POKE(Address, Value)
                // 1. Calculate Value -> A
                self.generate_expression(val_expr)?;
                self.output.push("  PHA".to_string()); // Push Value

                // 2. Calculate Address
                // If Address is a Constant Integer or Constant Identifier, we can use absolute addressing directly.
                // If it is a variable or expression, we need indirect addressing or self-modifying code.

                // Helper to check for constant address
                let const_addr = match addr_expr {
                    Expression::Integer(val) => Some(*val as u16),
                    Expression::Identifier(name) => self
                        .symbol_table
                        .resolve(name)
                        .and_then(|sym| sym.value.map(|val| val as u16)),
                    _ => None,
                };

                if let Some(addr) = const_addr {
                    self.output.push("  PLA".to_string()); // Restore Value to A
                    self.output.push(format!("  STA ${:04X}", addr));
                } else {
                    // Non-constant POKE
                    // We need to use indirect addressing (STA (ptr), Y)
                    // We can use $02,$03 as a temp pointer.

                    // A is on stack (Value)
                    // Eval address -> A
                    self.generate_expression(addr_expr)?;
                    // Assume 8-bit address for now if result is byte?
                    // Wait, address can be 16-bit. generate_expression only supports 8-bit returns generally right now.
                    // This is a limitation. If expr returns > 255 it's truncated in `generate_expression` for literals.
                    // But if it's a computation?
                    // Ideally we need `generate_expression_16`.

                    // For now, let's assume address is 8-bit or we just support lower byte, which is wrong.
                    // BUT, if the user does `POKE($2000, val)`, `Integer` handles > 255 if we relax the check.

                    // Let's implement full indirect store for POKE:
                    // Store Address Low in $02
                    self.output.push("  STA $02".to_string());
                    // Clear High Byte $03 (Assuming 8-bit addressing for dynamic computed pointers for now? Or fix later)
                    self.output.push("  LDA #$00".to_string());
                    self.output.push("  STA $03".to_string());

                    // Restore Value
                    self.output.push("  PLA".to_string());
                    // Indirect Store
                    self.output.push("  LDY #$00".to_string());
                    self.output.push("  STA ($02),y".to_string());
                }
            }
            Statement::If(cond, then_block, else_block) => {
                let else_label = self.new_label();
                let end_label = self.new_label();

                // 1. Evaluate Condition
                self.generate_expression(cond)?;
                // Result in A. 0 = False, Non-zero = True.

                // 2. Compare with 0
                self.output.push("  CMP #$00".to_string());
                // 3. Branch if Equal (False) to Else
                self.output.push(format!("  BEQ {}", else_label));

                // 4. Then Block
                self.generate_block(then_block)?;
                // 5. Jump to End
                self.output.push(format!("  JMP {}", end_label));

                // 6. Else Label
                self.output.push(format!("{}:", else_label));
                // 7. Else Block
                if let Some(block) = else_block {
                    self.generate_block(block)?;
                }

                // 8. End Label
                self.output.push(format!("{}:", end_label));
            }
            Statement::While(cond, body) => {
                let start_label = self.new_label();
                let end_label = self.new_label();

                self.output.push(format!("{}:", start_label));

                // Condition
                self.generate_expression(cond)?;
                self.output.push("  CMP #$00".to_string());
                self.output.push(format!("  BEQ {}", end_label));

                // Body
                self.generate_block(body)?;

                // Loop
                self.output.push(format!("  JMP {}", start_label));

                self.output.push(format!("{}:", end_label));
            }
            Statement::DoWhile(body, cond) => {
                let start_label = self.new_label();

                self.output.push(format!("{}:", start_label));

                // Body
                self.generate_block(body)?;

                // Condition
                self.generate_expression(cond)?;
                self.output.push("  CMP #$00".to_string());
                // Loop if Not Equal (True)
                self.output.push(format!("  BNE {}", start_label));
            }
            Statement::For(var_name, start, end, step, body) => {
                // FOR i = 0 TO 10 STEP 1
                let start_label = self.new_label();
                let end_label = self.new_label();

                // 1. Initialize Variable
                self.generate_expression(start)?;
                if let Some(sym) = self.symbol_table.resolve(var_name) {
                    if let Some(addr) = sym.address {
                         self.output.push(format!("  STA ${:04X}", addr));
                    } else {
                        return Err(format!("Variable '{}' not found for FOR loop", var_name));
                    }
                } else {
                    return Err(format!("Variable '{}' not found for FOR loop", var_name));
                }

                // 2. Loop Start
                self.output.push(format!("{}:", start_label));

                // 3. Condition Check: i <= end
                // Load i
                if let Some(sym) = self.symbol_table.resolve(var_name) {
                    if let Some(addr) = sym.address {
                         self.output.push(format!("  LDA ${:04X}", addr));
                    }
                }
                self.output.push("  PHA".to_string()); // Push i

                // Load End
                self.generate_expression(end)?;
                self.output.push("  STA $00".to_string()); // Store End in Temp
                self.output.push("  PLA".to_string()); // Restore i

                // Compare i (A) with End ($00)
                // If i > End, exit.
                // CMP End.
                // If A < M, C=0. If A >= M, C=1.
                // If A == M, Z=1.
                // We want i <= End. So if i > End, break.
                // i > End means A > M.
                // CMP sets Carry if A >= M. Zero if A == M.
                // If A > M, C=1 and Z=0.
                // If A == M, C=1 and Z=1.
                // If A < M, C=0.

                // This logic is tricky for signed vs unsigned. Assuming unsigned 8-bit.
                // We want to loop while i <= End.
                // So break if i > End.

                self.output.push("  CMP $00".to_string());
                // Branch if Greater (Unsigned uses BCC/BCS. Greater? BEQ is equal. BMI/BPL is signed.)
                // Unsigned:
                // BCC: Carry Clear (A < M)
                // BCS: Carry Set (A >= M)
                // BEQ: Equal

                // We want to Exit if A > M.
                // A > M is (A >= M) AND (A != M).
                // So BCS (>=) is true. Check BNE (!=).

                // Simpler: Compare and branch.
                // Or just use the BinaryOperator implementation?
                // But we don't have direct access to "Call LessThanOrEqual".

                // Let's implement the check manually:
                // i <= End
                // LDA i, CMP End
                // BEQ loop (Equal is ok)
                // BCC loop (Less is ok)
                // BCS exit (Greater or Equal -> but we handled Equal. So Greater)

                // Wait, BCS jumps if A >= M.
                // If A == M, BCS jumps. But we want to stay.
                // So checking logic:
                // CMP End
                // BEQ stay
                // BCC stay
                // JMP exit

                let loop_body_label = self.new_label();
                self.output.push(format!("  BEQ {}", loop_body_label)); // Equal -> Go to body
                self.output.push(format!("  BCC {}", loop_body_label)); // Less -> Go to body
                self.output.push(format!("  JMP {}", end_label)); // Greater -> Exit

                self.output.push(format!("{}:", loop_body_label));

                // 4. Body
                self.generate_block(body)?;

                // 5. Step
                // Load i
                 if let Some(sym) = self.symbol_table.resolve(var_name) {
                    if let Some(addr) = sym.address {
                         self.output.push(format!("  LDA ${:04X}", addr));
                    }
                }

                // Add Step
                if let Some(step_expr) = step {
                    self.output.push("  PHA".to_string());
                    self.generate_expression(step_expr)?;
                    self.output.push("  STA $00".to_string());
                    self.output.push("  PLA".to_string());
                    self.output.push("  CLC".to_string());
                    self.output.push("  ADC $00".to_string());
                } else {
                    // Default step 1
                    self.output.push("  CLC".to_string());
                    self.output.push("  ADC #1".to_string());
                }

                // Store i
                 if let Some(sym) = self.symbol_table.resolve(var_name) {
                    if let Some(addr) = sym.address {
                         self.output.push(format!("  STA ${:04X}", addr));
                    }
                }

                // 6. Jump back
                self.output.push(format!("  JMP {}", start_label));

                self.output.push(format!("{}:", end_label));
            }
            _ => {
                self.output
                    .push(format!("; Unimplemented statement: {:?}", stmt));
            }
        }
        Ok(())
    }

    fn generate_expression(&mut self, expr: &Expression) -> Result<(), String> {
        // Result should be left in Accumulator (A)
        match expr {
            Expression::Integer(val) => {
                // Load immediate
                // Allow larger values for POKE if they fit in 8-bit when masked
                let byte_val = (val & 0xFF) as u8;
                self.output.push(format!("  LDA #${:02X}", byte_val));
            }
            Expression::Identifier(name) => {
                if let Some(sym) = self.symbol_table.resolve(name) {
                    if let Some(addr) = sym.address {
                        self.output.push(format!("  LDA ${:04X} ; {}", addr, name));
                    } else if sym.kind == SymbolKind::Constant {
                        if let Some(val) = sym.value {
                            let byte_val = (val & 0xFF) as u8;
                            self.output.push(format!("  LDA #${:02X}", byte_val));
                        } else {
                            return Err(format!("Constant '{}' has no value assigned", name));
                        }
                    } else {
                        return Err(format!("Variable '{}' has no address", name));
                    }
                } else {
                    return Err(format!("Undefined variable '{}'", name));
                }
            }
            Expression::Peek(addr_expr) => {
                 // PEEK(Address)
                 // 1. Calculate Address -> A
                 // Problem: PEEK address is likely 16-bit ($2002).
                 // generate_expression for Integer returns LDA #LowByte.
                 // We need a way to load full address.
                 // But for now, let's assume we can compute the address and store in ZP.

                 // If addr is constant, we can use Absolute addressing.
                  let const_addr = match &**addr_expr {
                    Expression::Integer(val) => Some(*val as u16),
                    Expression::Identifier(name) => self
                        .symbol_table
                        .resolve(name)
                        .and_then(|sym| sym.value.map(|val| val as u16)),
                    _ => None,
                };

                if let Some(addr) = const_addr {
                    self.output.push(format!("  LDA ${:04X}", addr));
                } else {
                    // Indirect
                    self.generate_expression(addr_expr)?;
                    self.output.push("  STA $02".to_string());
                    self.output.push("  LDA #$00".to_string());
                    self.output.push("  STA $03".to_string());
                    self.output.push("  LDY #$00".to_string());
                    self.output.push("  LDA ($02),y".to_string());
                }
            }
            Expression::BinaryOp(left, op, right) => {
                // General case (Recursive) using Stack to preserve values:
                // 1. Eval Left -> A
                self.generate_expression(left)?;
                // 2. Push Left to Stack
                self.output.push("  PHA".to_string());

                // 3. Eval Right -> A
                self.generate_expression(right)?;

                // 4. Store Right in Temp ($00)
                // We need Right in memory for ADC/SBC.
                // Note: This overwrites $00, but since we are in a recursion,
                // any previous use of $00 by parent calls is finished or they pushed their results.
                self.output.push("  STA $00".to_string());

                // 5. Pull Left from Stack -> A
                self.output.push("  PLA".to_string());

                // 6. Perform Op: A (Left) op $00 (Right)
                match op {
                    BinaryOperator::Add => {
                        self.output.push("  CLC".to_string());
                        self.output.push("  ADC $00".to_string());
                    }
                    BinaryOperator::Subtract => {
                        self.output.push("  SEC".to_string());
                        self.output.push("  SBC $00".to_string());
                    }
                    BinaryOperator::And => {
                        self.output.push("  AND $00".to_string());
                    }
                    BinaryOperator::Or => {
                        self.output.push("  ORA $00".to_string());
                    }
                    BinaryOperator::Equal | BinaryOperator::NotEqual |
                    BinaryOperator::LessThan | BinaryOperator::GreaterThan |
                    BinaryOperator::LessThanOrEqual | BinaryOperator::GreaterThanOrEqual => {
                        // Compare A with $00
                        self.output.push("  CMP $00".to_string());

                        let true_label = self.new_label();
                        let end_label = self.new_label();

                        match op {
                            BinaryOperator::Equal => self.output.push(format!("  BEQ {}", true_label)),
                            BinaryOperator::NotEqual => self.output.push(format!("  BNE {}", true_label)),
                            BinaryOperator::LessThan => self.output.push(format!("  BCC {}", true_label)), // Unsigned <
                            BinaryOperator::GreaterThanOrEqual => self.output.push(format!("  BCS {}", true_label)), // Unsigned >=
                            BinaryOperator::GreaterThan => {
                                // Logic:
                                // CMP B.
                                // If A > B: C=1, Z=0.
                                // BEQ false (Equal)
                                // BCC false (Less)
                                // JMP true
                                let false_label = self.new_label();
                                self.output.push(format!("  BEQ {}", false_label)); // Equal -> False
                                self.output.push(format!("  BCC {}", false_label)); // Less -> False
                                self.output.push(format!("  JMP {}", true_label)); // Otherwise True

                                // Insert false label before the false block
                                // Note: The structure below puts false block immediately after this match.
                                // But we need to label it.
                                // Since we can't easily insert a label "before" the next lines outside this match without restructuring,
                                // We will emit the false label here and jump to it.
                                // Actually, we can just jump to a new label that we place right before LDA #0
                                // BUT the code below generates:
                                //   LDA #0
                                //   JMP end_label
                                //   true_label: ...

                                // So we need the jump target to be exactly where `LDA #0` is.
                                // Let's change the structure slightly to accomodate explicit false label.
                                self.output.push(format!("{}:", false_label));
                            },
                             BinaryOperator::LessThanOrEqual => {
                                // <= is < OR =
                                // BCC (Less) or BEQ (Equal)
                                self.output.push(format!("  BCC {}", true_label));
                                self.output.push(format!("  BEQ {}", true_label));
                            },
                            _ => {}
                        }

                        // False path
                        self.output.push("  LDA #0".to_string());
                        self.output.push(format!("  JMP {}", end_label));

                        // True path
                        self.output.push(format!("{}:", true_label));
                        self.output.push("  LDA #1".to_string());

                        self.output.push(format!("{}:", end_label));
                    }
                    _ => {
                        self.output
                            .push(format!("; Unimplemented binary op: {:?}", op));
                    }
                }
            }
            _ => {
                self.output
                    .push(format!("; Unimplemented expression: {:?}", expr));
            }
        }
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::compiler::ast::DataType;
    use crate::compiler::symbol_table::SymbolKind;

    #[test]
    fn test_codegen_var_assignment() {
        let mut st = SymbolTable::new();
        // Register symbols that analysis phase would have caught
        st.define("x".to_string(), DataType::Byte, SymbolKind::Variable)
            .unwrap();
        st.define("y".to_string(), DataType::Byte, SymbolKind::Variable)
            .unwrap();

        let program = Program {
            declarations: vec![
                TopLevel::Dim("x".to_string(), DataType::Byte),
                TopLevel::Dim("y".to_string(), DataType::Byte),
                TopLevel::Sub(
                    "Main".to_string(),
                    vec![],
                    vec![
                        Statement::Let("x".to_string(), Expression::Integer(10)),
                        Statement::Let(
                            "y".to_string(),
                            Expression::BinaryOp(
                                Box::new(Expression::Identifier("x".to_string())),
                                BinaryOperator::Add,
                                Box::new(Expression::Integer(5)),
                            ),
                        ),
                    ],
                ),
            ],
        };

        let mut cg = CodeGenerator::new(st);
        let code = cg.generate(&program).expect("Codegen failed");

        // Basic check of output
        assert!(code.iter().any(|line| line.contains("x @ $0300")));
        assert!(code.iter().any(|line| line.contains("y @ $0301")));
        assert!(code.iter().any(|line| line.contains("LDA #$0A"))); // 10
        assert!(code.iter().any(|line| line.contains("STA $0300")));
    }

    #[test]
    fn test_codegen_nested_expression() {
        // Test (1 + 2) + 3
        let mut st = SymbolTable::new();
        st.define("z".to_string(), DataType::Byte, SymbolKind::Variable)
            .unwrap();

        let program = Program {
            declarations: vec![
                TopLevel::Dim("z".to_string(), DataType::Byte),
                TopLevel::Sub(
                    "Main".to_string(),
                    vec![],
                    vec![Statement::Let(
                        "z".to_string(),
                        Expression::BinaryOp(
                            Box::new(Expression::BinaryOp(
                                Box::new(Expression::Integer(1)),
                                BinaryOperator::Add,
                                Box::new(Expression::Integer(2)),
                            )),
                            BinaryOperator::Add,
                            Box::new(Expression::Integer(3)),
                        ),
                    )],
                ),
            ],
        };

        let mut cg = CodeGenerator::new(st);
        let code = cg.generate(&program).expect("Codegen failed");

        // Verify structure:
        // 1. Eval Left Outer (1+2):
        //    Eval Left Inner (1) -> LDA #1 -> PHA
        //    Eval Right Inner (2) -> LDA #2 -> STA $00
        //    PLA -> ADC $00 -> Result 3 in A
        // 2. PHA (Push 3)
        // 3. Eval Right Outer (3) -> LDA #3 -> STA $00
        // 4. PLA (Pop 3) -> ADC $00 (3+3) -> Result 6
        // 5. STA z

        assert!(code.iter().any(|line| line.contains("STA $00")));
        assert!(code.iter().any(|line| line.contains("PHA")));
        assert!(code.iter().any(|line| line.contains("PLA")));
    }
}
