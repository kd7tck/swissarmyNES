use crate::compiler::ast::{Program, TopLevel, Statement, Expression, BinaryOperator};
use crate::compiler::symbol_table::SymbolTable;

pub struct CodeGenerator {
    symbol_table: SymbolTable, // We might need to clone or move the symbol table from Analyzer
    output: Vec<String>,
    ram_pointer: u16,
}

impl CodeGenerator {
    pub fn new(symbol_table: SymbolTable) -> Self {
        Self {
            symbol_table,
            output: Vec::new(),
            ram_pointer: 0x0000, // Zero Page start (or wherever we want to start)
        }
    }

    pub fn generate(&mut self, program: &Program) -> Result<Vec<String>, String> {
        self.output.clear();
        self.output.push("; Generated by SwissArmyNES".to_string());

        // Header stuff usually goes here (ines header), but we'll focus on code/vars for now
        // or just code segment.

        // Pass 1: Allocate variables
        self.allocate_memory(program)?;

        // Pass 2: Generate code
        for decl in &program.declarations {
            self.generate_top_level(decl)?;
        }

        Ok(self.output.clone())
    }

    fn allocate_memory(&mut self, program: &Program) -> Result<(), String> {
        // Simple allocation strategy: Linear allocation in Zero Page (0x00 - 0xFF)
        // or RAM (0x0200 - 0x07FF)

        // Reset pointer to start of user RAM (e.g., 0x0300 to avoid stack and system variables)
        // For 6502 NES, 0x00-0xFF is Zero Page (fast), 0x0100 is Stack. 0x0200 is OAM buffer usually.
        // Let's start at 0x0300 for global variables.
        self.ram_pointer = 0x0300;

        for decl in &program.declarations {
            if let TopLevel::Dim(name, _dtype) = decl {
                // Assign address
                // Update symbol table
                // We need to resolve the symbol first
                // The symbol table passed in `new` should already have these defined from Semantic Analysis
                // We just need to set the address.
                self.symbol_table.assign_address(name, self.ram_pointer)?;
                self.output.push(format!("; {} @ ${:04X}", name, self.ram_pointer));

                // Increment pointer (assume 1 byte for now for everything)
                // TODO: Handle WORD (2 bytes)
                self.ram_pointer += 1;
            }
        }
        Ok(())
    }

    fn generate_top_level(&mut self, decl: &TopLevel) -> Result<(), String> {
        match decl {
            TopLevel::Sub(name, _params, body) => {
                self.output.push(format!("{}:", name));
                self.generate_block(body)?;
                self.output.push("  RTS".to_string());
                self.output.push("".to_string()); // Newline for readability
            },
            TopLevel::Interrupt(name, body) => {
                self.output.push(format!("{}:", name));
                self.generate_block(body)?;
                self.output.push("  RTI".to_string());
                self.output.push("".to_string());
            },
            TopLevel::Const(_, _) => {
                // Constants are inlined usually, or we could emit equates?
                // For now, resolved at compile time if possible.
            },
            TopLevel::Dim(_, _) => {
                // Handled in allocation pass
            },
            TopLevel::Asm(lines) => {
                for line in lines {
                    self.output.push(format!("  {}", line));
                }
            }
        }
        Ok(())
    }

    fn generate_block(&mut self, statements: &[Statement]) -> Result<(), String> {
        for stmt in statements {
            self.generate_statement(stmt)?;
        }
        Ok(())
    }

    fn generate_statement(&mut self, stmt: &Statement) -> Result<(), String> {
        match stmt {
            Statement::Let(name, expr) => {
                // 1. Evaluate expression -> result in A (Accumulator)
                self.generate_expression(expr)?;

                // 2. Store A into variable address
                if let Some(sym) = self.symbol_table.resolve(name) {
                    if let Some(addr) = sym.address {
                        self.output.push(format!("  STA ${:04X} ; {}", addr, name));
                    } else {
                        // If it's a local variable (allocated on stack or temp zp), handling is more complex.
                        // For Phase 7, maybe we assume only globals or we allocate locals too?
                        return Err(format!("Variable '{}' has no address assigned (Locals not supported yet)", name));
                    }
                } else {
                     return Err(format!("Undefined variable '{}'", name));
                }
            },
            Statement::Asm(lines) => {
                for line in lines {
                    self.output.push(format!("  {}", line));
                }
            },
            // TODO: Handle other statements (If, While, etc in Phase 8)
            _ => {
                self.output.push(format!("; Unimplemented statement: {:?}", stmt));
            }
        }
        Ok(())
    }

    fn generate_expression(&mut self, expr: &Expression) -> Result<(), String> {
        // Result should be left in Accumulator (A)
        match expr {
            Expression::Integer(val) => {
                // Load immediate
                if *val > 255 || *val < -128 {
                    // For now, only 8-bit immediate values are supported
                    // We could treat > 255 as error, but keeping silent truncation matching original behavior for now,
                    // just explicit about it or error?
                    // Let's return error to be safe as per "Improve Code Safety" plan.
                    return Err(format!("Integer literal {} exceeds 8-bit limit (0-255)", val));
                }

                // Mask to 8-bit to ensure valid assembly
                let byte_val = (val & 0xFF) as u8;
                self.output.push(format!("  LDA #${:02X}", byte_val));
            },
            Expression::Identifier(name) => {
                if let Some(sym) = self.symbol_table.resolve(name) {
                     if let Some(addr) = sym.address {
                         self.output.push(format!("  LDA ${:04X} ; {}", addr, name));
                     } else if sym.kind == crate::compiler::symbol_table::SymbolKind::Constant {
                         if let Some(val) = sym.value {
                             let byte_val = (val & 0xFF) as u8;
                             self.output.push(format!("  LDA #${:02X}", byte_val));
                         } else {
                             return Err(format!("Constant '{}' has no value assigned", name));
                         }
                     } else {
                         return Err(format!("Variable '{}' has no address", name));
                     }
                } else {
                    return Err(format!("Undefined variable '{}'", name));
                }
            },
            Expression::BinaryOp(left, op, right) => {
                // General case (Recursive) using Stack to preserve values:
                // 1. Eval Left -> A
                self.generate_expression(left)?;
                // 2. Push Left to Stack
                self.output.push("  PHA".to_string());

                // 3. Eval Right -> A
                self.generate_expression(right)?;

                // 4. Store Right in Temp ($00)
                // We need Right in memory for ADC/SBC.
                // Note: This overwrites $00, but since we are in a recursion,
                // any previous use of $00 by parent calls is finished or they pushed their results.
                self.output.push("  STA $00".to_string());

                // 5. Pull Left from Stack -> A
                self.output.push("  PLA".to_string());

                // 6. Perform Op: A (Left) op $00 (Right)
                match op {
                    BinaryOperator::Add => {
                        self.output.push("  CLC".to_string());
                        self.output.push("  ADC $00".to_string());
                    },
                    BinaryOperator::Subtract => {
                        self.output.push("  SEC".to_string());
                        self.output.push("  SBC $00".to_string());
                    },
                    BinaryOperator::And => {
                        self.output.push("  AND $00".to_string());
                    },
                    BinaryOperator::Or => {
                        self.output.push("  ORA $00".to_string());
                    },
                     // TODO: Multiply/Divide/Compare
                    _ => {
                         self.output.push(format!("; Unimplemented binary op: {:?}", op));
                    }
                }
            },
            _ => {
                self.output.push(format!("; Unimplemented expression: {:?}", expr));
            }
        }
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::compiler::ast::DataType;
    use crate::compiler::symbol_table::SymbolKind;

    #[test]
    fn test_codegen_var_assignment() {
        let mut st = SymbolTable::new();
        // Register symbols that analysis phase would have caught
        st.define("x".to_string(), DataType::Byte, SymbolKind::Variable).unwrap();
        st.define("y".to_string(), DataType::Byte, SymbolKind::Variable).unwrap();

        let program = Program {
            declarations: vec![
                TopLevel::Dim("x".to_string(), DataType::Byte),
                TopLevel::Dim("y".to_string(), DataType::Byte),
                TopLevel::Sub("Main".to_string(), vec![], vec![
                    Statement::Let("x".to_string(), Expression::Integer(10)),
                    Statement::Let("y".to_string(), Expression::BinaryOp(
                        Box::new(Expression::Identifier("x".to_string())),
                        BinaryOperator::Add,
                        Box::new(Expression::Integer(5))
                    ))
                ])
            ]
        };

        let mut cg = CodeGenerator::new(st);
        let code = cg.generate(&program).expect("Codegen failed");

        // Basic check of output
        assert!(code.iter().any(|line| line.contains("x @ $0300")));
        assert!(code.iter().any(|line| line.contains("y @ $0301")));
        assert!(code.iter().any(|line| line.contains("LDA #$0A"))); // 10
        assert!(code.iter().any(|line| line.contains("STA $0300")));
    }

    #[test]
    fn test_codegen_nested_expression() {
        // Test (1 + 2) + 3
        let mut st = SymbolTable::new();
        st.define("z".to_string(), DataType::Byte, SymbolKind::Variable).unwrap();

        let program = Program {
            declarations: vec![
                TopLevel::Dim("z".to_string(), DataType::Byte),
                TopLevel::Sub("Main".to_string(), vec![], vec![
                    Statement::Let("z".to_string(), Expression::BinaryOp(
                        Box::new(Expression::BinaryOp(
                            Box::new(Expression::Integer(1)),
                            BinaryOperator::Add,
                            Box::new(Expression::Integer(2))
                        )),
                        BinaryOperator::Add,
                        Box::new(Expression::Integer(3))
                    ))
                ])
            ]
        };

        let mut cg = CodeGenerator::new(st);
        let code = cg.generate(&program).expect("Codegen failed");

        // Verify structure:
        // 1. Eval Left Outer (1+2):
        //    Eval Left Inner (1) -> LDA #1 -> PHA
        //    Eval Right Inner (2) -> LDA #2 -> STA $00
        //    PLA -> ADC $00 -> Result 3 in A
        // 2. PHA (Push 3)
        // 3. Eval Right Outer (3) -> LDA #3 -> STA $00
        // 4. PLA (Pop 3) -> ADC $00 (3+3) -> Result 6
        // 5. STA z

        assert!(code.iter().any(|line| line.contains("STA $00")));
        assert!(code.iter().any(|line| line.contains("PHA")));
        assert!(code.iter().any(|line| line.contains("PLA")));
    }
}
