use crate::compiler::ast::{
    BinaryOperator, Expression, Program, Statement, TopLevel, UnaryOperator,
};
use crate::compiler::symbol_table::{SymbolKind, SymbolTable};

pub const NAMETABLE_ADDR: u16 = 0xD500;
pub const VAR_START_RAM: u16 = 0x0300;

pub struct CodeGenerator {
    symbol_table: SymbolTable,
    output: Vec<String>,
    ram_pointer: u16,
    label_counter: usize,
}

impl CodeGenerator {
    pub fn new(symbol_table: SymbolTable) -> Self {
        Self {
            symbol_table,
            output: Vec::new(),
            ram_pointer: VAR_START_RAM,
            label_counter: 0,
        }
    }

    fn new_label(&mut self) -> String {
        self.label_counter += 1;
        format!("__L{}", self.label_counter)
    }

    pub fn generate(&mut self, program: &Program) -> Result<Vec<String>, String> {
        self.output.clear();
        self.output.push(".ORG $8000".to_string()); // Start of PRG ROM
        self.output.push("; Generated by SwissArmyNES".to_string());

        // Pass 1: Allocate variables
        self.allocate_memory(program)?;

        // Pass 2: Generate code
        self.generate_startup_routine(program)?;

        for decl in &program.declarations {
            self.generate_top_level(decl)?;
        }

        // Pass 3: Generate Sound Engine Code
        self.generate_sound_engine();

        // Pass 4: Generate Vectors
        self.generate_vectors(program)?;

        Ok(self.output.clone())
    }

    fn generate_startup_routine(&mut self, _program: &Program) -> Result<(), String> {
        self.output.push("Startup:".to_string());
        self.output
            .push("  SEI          ; Disable IRQs".to_string());
        self.output
            .push("  CLD          ; Disable Decimal Mode".to_string());
        self.output.push("  LDX #$40".to_string());
        self.output
            .push("  STX $4017    ; Disable APU frame IRQ".to_string());
        self.output.push("  LDX #$FF".to_string());
        self.output
            .push("  TXS          ; Set Stack Pointer to $FF".to_string());
        self.output.push("  INX          ; X = 0".to_string());
        self.output.push("  STX $2000    ; Disable NMI".to_string());
        self.output
            .push("  STX $2001    ; Disable Rendering".to_string());
        self.output
            .push("  STX $4010    ; Disable DMC IRQs".to_string());

        // Wait for VBLANK (1)
        self.output.push("vblankwait1:".to_string());
        self.output.push("  BIT $2002".to_string());
        self.output.push("  BPL vblankwait1".to_string());

        // Clear Memory (RAM)
        self.output.push("clrmem:".to_string());
        self.output.push("  LDA #$00".to_string());
        self.output.push("  STA $00,x".to_string());
        self.output.push("  STA $0100,x".to_string());
        self.output.push("  STA $0300,x".to_string());
        self.output.push("  STA $0400,x".to_string());
        self.output.push("  STA $0500,x".to_string());
        self.output.push("  STA $0600,x".to_string());
        self.output.push("  STA $0700,x".to_string());
        self.output.push("  LDA #$FE".to_string());
        self.output
            .push("  STA $0200,x ; Move sprites offscreen".to_string());
        self.output.push("  INX".to_string());
        self.output.push("  BNE clrmem".to_string());

        // Wait for VBLANK (2)
        self.output.push("vblankwait2:".to_string());
        self.output.push("  BIT $2002".to_string());
        self.output.push("  BPL vblankwait2".to_string());

        // --- Load Palette ---
        self.output.push("  ; Load Palettes".to_string());
        self.output.push("  LDA #$3F".to_string());
        self.output.push("  STA $2006".to_string());
        self.output.push("  LDA #$00".to_string());
        self.output.push("  STA $2006".to_string());

        self.output.push("  LDX #$00".to_string());
        self.output.push("LoadPalLoop:".to_string());
        self.output.push("  LDA $E000, X".to_string());
        self.output.push("  STA $2007".to_string());
        self.output.push("  INX".to_string());
        self.output.push("  CPX #32".to_string());
        self.output.push("  BNE LoadPalLoop".to_string());

        // --- Load Nametable ---
        self.output.push("  ; Load Nametable".to_string());
        self.output.push("  LDA #$20".to_string());
        self.output.push("  STA $2006".to_string());
        self.output.push("  LDA #$00".to_string());
        self.output.push("  STA $2006".to_string());

        // Loop 1 (0-255)
        self.output.push("  LDX #$00".to_string());
        self.output.push("LoadNT1:".to_string());
        self.output
            .push(format!("  LDA ${:04X}, X", NAMETABLE_ADDR));
        self.output.push("  STA $2007".to_string());
        self.output.push("  INX".to_string());
        self.output.push("  BNE LoadNT1".to_string());

        // Loop 2 (256-511)
        self.output.push("  LDX #$00".to_string());
        self.output.push("LoadNT2:".to_string());
        self.output
            .push(format!("  LDA ${:04X}, X", NAMETABLE_ADDR + 256));
        self.output.push("  STA $2007".to_string());
        self.output.push("  INX".to_string());
        self.output.push("  BNE LoadNT2".to_string());

        // Loop 3 (512-767)
        self.output.push("  LDX #$00".to_string());
        self.output.push("LoadNT3:".to_string());
        self.output
            .push(format!("  LDA ${:04X}, X", NAMETABLE_ADDR + 512));
        self.output.push("  STA $2007".to_string());
        self.output.push("  INX".to_string());
        self.output.push("  BNE LoadNT3".to_string());

        // Loop 4 (768-1023)
        self.output.push("  LDX #$00".to_string());
        self.output.push("LoadNT4:".to_string());
        self.output
            .push(format!("  LDA ${:04X}, X", NAMETABLE_ADDR + 768));
        self.output.push("  STA $2007".to_string());
        self.output.push("  INX".to_string());
        self.output.push("  BNE LoadNT4".to_string());

        // Initialize Sound Engine
        self.output.push("  JSR Sound_Init".to_string());

        // Call Main if it exists
        self.output.push("  JSR Main".to_string());

        // Infinite loop after Main returns
        self.output.push("forever:".to_string());
        self.output.push("  JMP forever".to_string());
        self.output.push("".to_string());

        // Default RTI
        self.output.push("DefaultRTI:".to_string());
        self.output.push("  RTI".to_string());
        self.output.push("".to_string());

        Ok(())
    }

    fn generate_sound_engine(&mut self) {
        // Simple Sound Engine
        self.output.push("; --- Sound Engine ---".to_string());
        self.output.push("Sound_Init:".to_string());
        self.output.push("  LDA #$0F".to_string());
        self.output
            .push("  STA $4015    ; Enable Square 1, 2, Triangle, Noise".to_string());
        self.output.push("  LDA #$00".to_string());
        self.output
            .push("  STA $02F0    ; Clear SFX_ID".to_string());
        self.output
            .push("  STA $02F1    ; Clear SFX_Timer".to_string());
        self.output.push("  RTS".to_string());

        self.output.push("Sound_Play:".to_string());
        self.output.push("  ; Input: A = SFX ID".to_string());
        self.output.push("  CMP #$01".to_string());
        self.output.push("  BEQ Play_Jump".to_string());
        self.output.push("  CMP #$02".to_string());
        self.output.push("  BEQ Play_Shoot".to_string());
        self.output.push("  RTS".to_string());

        self.output.push("Play_Jump:".to_string());
        self.output
            .push("  LDA #$9F       ; Duty 50%, Vol 15, Env Off".to_string());
        self.output.push("  STA $4000".to_string());
        self.output
            .push("  LDA #$C9       ; Period Low".to_string());
        self.output.push("  STA $4002".to_string());
        self.output
            .push("  LDA #$08       ; LengthCounter 0, High Period 0".to_string());
        self.output.push("  STA $4003".to_string());
        self.output.push("  ; Sweep".to_string());
        self.output
            .push("  LDA #$99       ; Enabled, Period 1, Shift 1".to_string());
        self.output.push("  STA $4001".to_string());
        self.output.push("  RTS".to_string());

        self.output.push("Play_Shoot:".to_string());
        self.output
            .push("  LDA #$9F       ; Duty 50%, Vol 15, Env Off".to_string());
        self.output.push("  STA $400C".to_string());
        self.output.push("  LDA #$06       ; Period 6".to_string());
        self.output.push("  STA $400E".to_string());
        self.output
            .push("  LDA #$08       ; Length Counter 0".to_string());
        self.output.push("  STA $400F".to_string());
        self.output.push("  RTS".to_string());
    }

    fn generate_vectors(&mut self, program: &Program) -> Result<(), String> {
        self.output.push("".to_string());
        self.output.push(".ORG $FFFA".to_string());

        // Find NMI Handler
        let nmi_label = program.declarations.iter().find_map(|d| {
            if let TopLevel::Interrupt(name, _) = d {
                if name.to_uppercase() == "NMI" {
                    return Some(name.clone());
                }
            }
            None
        });

        // Find IRQ Handler
        let irq_label = program.declarations.iter().find_map(|d| {
            if let TopLevel::Interrupt(name, _) = d {
                if name.to_uppercase() == "IRQ" {
                    return Some(name.clone());
                }
            }
            None
        });

        // Emit Vectors
        // NMI
        if let Some(lbl) = &nmi_label {
            self.output.push(format!("VecNMI: WORD {}", lbl));
        } else {
            self.output.push("VecNMI: WORD DefaultRTI".to_string());
        }

        // RESET
        self.output.push("VecReset: WORD Startup".to_string());

        // IRQ
        if let Some(lbl) = &irq_label {
            self.output.push(format!("VecIRQ: WORD {}", lbl));
        } else {
            self.output.push("VecIRQ: WORD DefaultRTI".to_string());
        }

        self.output.push("".to_string());

        Ok(())
    }

    fn allocate_memory(&mut self, program: &Program) -> Result<(), String> {
        self.ram_pointer = VAR_START_RAM;

        for decl in &program.declarations {
            if let TopLevel::Dim(name, dtype) = decl {
                self.symbol_table.assign_address(name, self.ram_pointer)?;
                self.output
                    .push(format!("; {} @ ${:04X}", name, self.ram_pointer));

                match dtype {
                    crate::compiler::ast::DataType::Byte | crate::compiler::ast::DataType::Bool => {
                        self.ram_pointer += 1;
                    }
                    crate::compiler::ast::DataType::Word => {
                        self.ram_pointer += 2;
                    }
                }
            }
        }
        Ok(())
    }

    fn generate_top_level(&mut self, decl: &TopLevel) -> Result<(), String> {
        match decl {
            TopLevel::Sub(name, _params, body) => {
                self.output.push(format!("{}:", name));
                self.generate_block(body)?;
                self.output.push("  RTS".to_string());
                self.output.push("".to_string());
            }
            TopLevel::Interrupt(name, body) => {
                self.output.push(format!("{}:", name));
                self.generate_block(body)?;
                self.output.push("  RTI".to_string());
                self.output.push("".to_string());
            }
            TopLevel::Const(_, _) => {
            }
            TopLevel::Dim(_, _) => {
            }
            TopLevel::Asm(lines) => {
                for line in lines {
                    self.output.push(format!("  {}", line));
                }
            }
        }
        Ok(())
    }

    fn generate_block(&mut self, statements: &[Statement]) -> Result<(), String> {
        for stmt in statements {
            self.generate_statement(stmt)?;
        }
        Ok(())
    }

    fn generate_statement(&mut self, stmt: &Statement) -> Result<(), String> {
        match stmt {
            Statement::Let(name, expr) => {
                self.generate_expression(expr)?;

                if let Some(sym) = self.symbol_table.resolve(name) {
                    if let Some(addr) = sym.address {
                        self.output.push(format!("  STA ${:04X} ; {}", addr, name));
                    } else {
                        return Err(format!(
                            "Variable '{}' has no address assigned (Locals not supported yet)",
                            name
                        ));
                    }
                } else {
                    return Err(format!("Undefined variable '{}'", name));
                }
            }
            Statement::Asm(lines) => {
                for line in lines {
                    self.output.push(format!("  {}", line));
                }
            }
            Statement::Poke(addr_expr, val_expr) => {
                self.generate_expression(val_expr)?;
                self.output.push("  PHA".to_string()); // Push Value

                let const_addr = match addr_expr {
                    Expression::Integer(val) => Some(*val as u16),
                    Expression::Identifier(name) => self
                        .symbol_table
                        .resolve(name)
                        .and_then(|sym| sym.value.map(|val| val as u16)),
                    _ => None,
                };

                if let Some(addr) = const_addr {
                    self.output.push("  PLA".to_string()); // Restore Value to A
                    self.output.push(format!("  STA ${:04X}", addr));
                } else {
                    self.output
                        .push("  ; Dynamic POKE (Indirect ZP)".to_string());
                    self.generate_expression(addr_expr)?;
                    self.output.push("  STA $02".to_string());
                    self.output.push("  LDA #$00".to_string());
                    self.output.push("  STA $03".to_string());
                    self.output.push("  LDY #$00".to_string());
                    self.output.push("  PLA".to_string());
                    self.output.push("  STA ($02),y".to_string());
                }
            }
            Statement::If(condition, then_block, else_block) => {
                let else_label = self.new_label();
                let end_label = self.new_label();

                self.generate_expression(condition)?;
                self.output.push("  CMP #0".to_string());
                if else_block.is_some() {
                    self.output.push(format!("  BEQ {}", else_label));
                } else {
                    self.output.push(format!("  BEQ {}", end_label));
                }

                self.generate_block(then_block)?;
                self.output.push(format!("  JMP {}", end_label));

                if let Some(else_stmts) = else_block {
                    self.output.push(format!("{}:", else_label));
                    self.generate_block(else_stmts)?;
                }

                self.output.push(format!("{}:", end_label));
            }
            Statement::While(condition, body) => {
                let start_label = self.new_label();
                let end_label = self.new_label();

                self.output.push(format!("{}:", start_label));
                self.generate_expression(condition)?;
                self.output.push("  CMP #0".to_string());
                self.output.push(format!("  BEQ {}", end_label));

                self.generate_block(body)?;
                self.output.push(format!("  JMP {}", start_label));
                self.output.push(format!("{}:", end_label));
            }
            Statement::DoWhile(body, condition) => {
                let start_label = self.new_label();
                self.output.push(format!("{}:", start_label));

                self.generate_block(body)?;
                self.generate_expression(condition)?;
                self.output.push("  CMP #0".to_string());
                self.output.push(format!("  BNE {}", start_label));
            }
            Statement::For(var_name, start_expr, end_expr, step_expr, body) => {
                let loop_label = self.new_label();
                let exit_label = self.new_label();

                self.generate_statement(&Statement::Let(var_name.clone(), start_expr.clone()))?;

                self.output.push(format!("{}:", loop_label));

                self.generate_expression(&Expression::Identifier(var_name.clone()))?;
                self.output.push("  PHA".to_string());

                self.generate_expression(end_expr)?;
                self.output.push("  STA $00".to_string());

                self.output.push("  PLA".to_string());
                self.output.push("  CMP $00".to_string());

                let body_label = self.new_label();
                self.output.push(format!("  BEQ {}", body_label));
                self.output.push(format!("  BCC {}", body_label));
                self.output.push(format!("  JMP {}", exit_label));

                self.output.push(format!("{}:", body_label));

                self.generate_block(body)?;

                self.generate_expression(&Expression::Identifier(var_name.clone()))?;
                self.output.push("  PHA".to_string());

                if let Some(step) = step_expr {
                    self.generate_expression(step)?;
                } else {
                    self.output.push("  LDA #1".to_string());
                }
                self.output.push("  STA $00".to_string());
                self.output.push("  PLA".to_string());
                self.output.push("  CLC".to_string());
                self.output.push("  ADC $00".to_string());

                if let Some(sym) = self.symbol_table.resolve(var_name) {
                    if let Some(addr) = sym.address {
                        self.output.push(format!("  STA ${:04X}", addr));
                    }
                }

                self.output.push(format!("  JMP {}", loop_label));
                self.output.push(format!("{}:", exit_label));
            }
            Statement::Return(expr) => {
                if let Some(e) = expr {
                    self.generate_expression(e)?;
                }
                self.output.push("  RTS".to_string());
            }
            Statement::Call(name, _args) => {
                self.output.push(format!("  JSR {}", name));
            }
            Statement::Print(_) => {
                self.output
                    .push("  ; PRINT not supported on NES target directly".to_string());
            }
            Statement::Comment(c) => {
                self.output.push(format!("  ; {}", c));
            }
            Statement::On(vector, routine) => {
                // Not implemented due to assembler limitations
                self.output.push(format!(
                    "  ; ON {} DO {} (Not implemented: Assembler limitation)",
                    vector, routine
                ));
            }
            Statement::PlaySfx(id_expr) => {
                self.generate_expression(id_expr)?;
                self.output.push("  JSR Sound_Play".to_string());
            }
        }
        Ok(())
    }

    fn generate_expression(&mut self, expr: &Expression) -> Result<(), String> {
        match expr {
            Expression::Integer(val) => {
                if *val > 255 || *val < -128 {
                    return Err(format!(
                        "Integer literal {} exceeds 8-bit limit (0-255)",
                        val
                    ));
                }
                let byte_val = (val & 0xFF) as u8;
                self.output.push(format!("  LDA #${:02X}", byte_val));
            }
            Expression::Identifier(name) => {
                if let Some(sym) = self.symbol_table.resolve(name) {
                    if let Some(addr) = sym.address {
                        self.output.push(format!("  LDA ${:04X} ; {}", addr, name));
                    } else if sym.kind == SymbolKind::Constant {
                        if let Some(val) = sym.value {
                            let byte_val = (val & 0xFF) as u8;
                            self.output.push(format!("  LDA #${:02X}", byte_val));
                        } else {
                            return Err(format!("Constant '{}' has no value assigned", name));
                        }
                    } else {
                        return Err(format!("Variable '{}' has no address", name));
                    }
                } else {
                    return Err(format!("Undefined variable '{}'", name));
                }
            }
            Expression::Peek(addr_expr) => {
                let const_addr = match &**addr_expr {
                    Expression::Integer(val) => Some(*val as u16),
                    Expression::Identifier(name) => self
                        .symbol_table
                        .resolve(name)
                        .and_then(|sym| sym.value.map(|val| val as u16)),
                    _ => None,
                };

                if let Some(addr) = const_addr {
                    self.output.push(format!("  LDA ${:04X}", addr));
                } else {
                    // Dynamic PEEK (Indirect ZP)
                    self.generate_expression(addr_expr)?;
                    self.output.push("  STA $02".to_string());
                    self.output.push("  LDA #$00".to_string());
                    self.output.push("  STA $03".to_string());
                    self.output.push("  LDY #$00".to_string());
                    self.output.push("  LDA ($02),y".to_string());
                }
            }
            Expression::UnaryOp(op, operand) => {
                self.generate_expression(operand)?;
                match op {
                    UnaryOperator::Negate => {
                        self.output.push("  EOR #$FF".to_string());
                        self.output.push("  CLC".to_string());
                        self.output.push("  ADC #01".to_string());
                    }
                    UnaryOperator::Not => {
                        let false_label = self.new_label();
                        let done_label = self.new_label();
                        self.output.push("  CMP #0".to_string());
                        self.output.push(format!("  BNE {}", false_label));
                        self.output.push("  LDA #1".to_string());
                        self.output.push(format!("  JMP {}", done_label));
                        self.output.push(format!("{}:", false_label));
                        self.output.push("  LDA #0".to_string());
                        self.output.push(format!("{}:", done_label));
                    }
                }
            }
            Expression::BinaryOp(left, op, right) => {
                self.generate_expression(left)?;
                self.output.push("  PHA".to_string());
                self.generate_expression(right)?;
                self.output.push("  STA $00".to_string());
                self.output.push("  PLA".to_string());

                match op {
                    BinaryOperator::Add => {
                        self.output.push("  CLC".to_string());
                        self.output.push("  ADC $00".to_string());
                    }
                    BinaryOperator::Subtract => {
                        self.output.push("  SEC".to_string());
                        self.output.push("  SBC $00".to_string());
                    }
                    BinaryOperator::And => {
                        self.output.push("  AND $00".to_string());
                    }
                    BinaryOperator::Or => {
                        self.output.push("  ORA $00".to_string());
                    }
                    BinaryOperator::Equal => {
                        let true_lbl = self.new_label();
                        let end_lbl = self.new_label();
                        self.output.push("  CMP $00".to_string());
                        self.output.push(format!("  BEQ {}", true_lbl));
                        self.output.push("  LDA #0".to_string());
                        self.output.push(format!("  JMP {}", end_lbl));
                        self.output.push(format!("{}:", true_lbl));
                        self.output.push("  LDA #1".to_string());
                        self.output.push(format!("{}:", end_lbl));
                    }
                    BinaryOperator::NotEqual => {
                        let true_lbl = self.new_label();
                        let end_lbl = self.new_label();
                        self.output.push("  CMP $00".to_string());
                        self.output.push(format!("  BNE {}", true_lbl));
                        self.output.push("  LDA #0".to_string());
                        self.output.push(format!("  JMP {}", end_lbl));
                        self.output.push(format!("{}:", true_lbl));
                        self.output.push("  LDA #1".to_string());
                        self.output.push(format!("{}:", end_lbl));
                    }
                    BinaryOperator::LessThan => {
                        let true_lbl = self.new_label();
                        let end_lbl = self.new_label();
                        self.output.push("  CMP $00".to_string());
                        self.output.push(format!("  BCC {}", true_lbl));
                        self.output.push("  LDA #0".to_string());
                        self.output.push(format!("  JMP {}", end_lbl));
                        self.output.push(format!("{}:", true_lbl));
                        self.output.push("  LDA #1".to_string());
                        self.output.push(format!("{}:", end_lbl));
                    }
                    BinaryOperator::GreaterThan => {
                        let true_lbl = self.new_label();
                        let false_lbl = self.new_label();
                        let end_lbl = self.new_label();

                        self.output.push("  CMP $00".to_string());
                        self.output.push(format!("  BEQ {}", false_lbl));
                        self.output.push(format!("  BCC {}", false_lbl));
                        self.output.push(format!("  BCS {}", true_lbl));

                        self.output.push(format!("{}:", false_lbl));
                        self.output.push("  LDA #0".to_string());
                        self.output.push(format!("  JMP {}", end_lbl));

                        self.output.push(format!("{}:", true_lbl));
                        self.output.push("  LDA #1".to_string());
                        self.output.push(format!("{}:", end_lbl));
                    }
                    BinaryOperator::LessThanOrEqual => {
                        let true_lbl = self.new_label();
                        let end_lbl = self.new_label();

                        self.output.push("  CMP $00".to_string());
                        self.output.push(format!("  BEQ {}", true_lbl));
                        self.output.push(format!("  BCC {}", true_lbl));
                        self.output.push("  LDA #0".to_string());
                        self.output.push(format!("  JMP {}", end_lbl));

                        self.output.push(format!("{}:", true_lbl));
                        self.output.push("  LDA #1".to_string());
                        self.output.push(format!("{}:", end_lbl));
                    }
                    BinaryOperator::GreaterThanOrEqual => {
                        let true_lbl = self.new_label();
                        let end_lbl = self.new_label();

                        self.output.push("  CMP $00".to_string());
                        self.output.push(format!("  BCS {}", true_lbl));
                        self.output.push("  LDA #0".to_string());
                        self.output.push(format!("  JMP {}", end_lbl));
                        self.output.push(format!("{}:", true_lbl));
                        self.output.push("  LDA #1".to_string());
                        self.output.push(format!("{}:", end_lbl));
                    }
                    _ => {
                        self.output
                            .push(format!("; Unimplemented binary op: {:?}", op));
                    }
                }
            }
            _ => {
                self.output
                    .push(format!("; Unimplemented expression: {:?}", expr));
            }
        }
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::compiler::ast::DataType;
    use crate::compiler::symbol_table::{SymbolKind, SymbolTable};

    #[test]
    fn test_codegen_var_assignment() {
        let mut st = SymbolTable::new();
        st.define("x".to_string(), DataType::Byte, SymbolKind::Variable)
            .unwrap();
        st.define("y".to_string(), DataType::Byte, SymbolKind::Variable)
            .unwrap();

        let program = Program {
            declarations: vec![
                TopLevel::Dim("x".to_string(), DataType::Byte),
                TopLevel::Dim("y".to_string(), DataType::Byte),
                TopLevel::Sub(
                    "Main".to_string(),
                    vec![],
                    vec![
                        Statement::Let("x".to_string(), Expression::Integer(10)),
                        Statement::Let(
                            "y".to_string(),
                            Expression::BinaryOp(
                                Box::new(Expression::Identifier("x".to_string())),
                                BinaryOperator::Add,
                                Box::new(Expression::Integer(5)),
                            ),
                        ),
                    ],
                ),
            ],
        };

        let mut cg = CodeGenerator::new(st);
        let code = cg.generate(&program).expect("Codegen failed");

        // x is first, so $0300
        assert!(code.iter().any(|line| line.contains("x @ $0300")));
        assert!(code.iter().any(|line| line.contains("y @ $0301")));
        assert!(code.iter().any(|line| line.contains("LDA #$0A")));
        assert!(code.iter().any(|line| line.contains("STA $0300")));
    }

    #[test]
    fn test_codegen_nested_expression() {
        let mut st = SymbolTable::new();
        st.define("z".to_string(), DataType::Byte, SymbolKind::Variable)
            .unwrap();

        let program = Program {
            declarations: vec![
                TopLevel::Dim("z".to_string(), DataType::Byte),
                TopLevel::Sub(
                    "Main".to_string(),
                    vec![],
                    vec![Statement::Let(
                        "z".to_string(),
                        Expression::BinaryOp(
                            Box::new(Expression::BinaryOp(
                                Box::new(Expression::Integer(1)),
                                BinaryOperator::Add,
                                Box::new(Expression::Integer(2)),
                            )),
                            BinaryOperator::Add,
                            Box::new(Expression::Integer(3)),
                        ),
                    )],
                ),
            ],
        };

        let mut cg = CodeGenerator::new(st);
        let code = cg.generate(&program).expect("Codegen failed");

        assert!(code.iter().any(|line| line.contains("STA $00")));
        assert!(code.iter().any(|line| line.contains("PHA")));
        assert!(code.iter().any(|line| line.contains("PLA")));
    }
}
