use crate::compiler::ast::{
    BinaryOperator, DataType, Expression, Program, Statement, TopLevel, UnaryOperator,
};
use crate::compiler::symbol_table::{SymbolKind, SymbolTable};
use std::collections::HashMap;

pub const NAMETABLE_ADDR: u16 = 0xD500;

pub struct CodeGenerator {
    symbol_table: SymbolTable,
    output: Vec<String>,
    ram_pointer: u16,
    label_counter: usize,
    data_table_offsets: HashMap<String, u16>,
    sub_signatures: HashMap<String, Vec<(u16, DataType)>>,
    string_literals: HashMap<String, String>,
}

impl CodeGenerator {
    pub fn new(symbol_table: SymbolTable) -> Self {
        Self {
            symbol_table,
            output: Vec::new(),
            ram_pointer: 0x0000,
            label_counter: 0,
            data_table_offsets: HashMap::new(),
            sub_signatures: HashMap::new(),
            string_literals: HashMap::new(),
        }
    }

    fn new_label(&mut self) -> String {
        self.label_counter += 1;
        format!("GEN_L{}", self.label_counter)
    }

    pub fn generate(&mut self, program: &Program) -> Result<Vec<String>, String> {
        self.output.clear();
        self.output.push(".ORG $8000".to_string());
        self.output.push("; Generated by SwissArmyNES".to_string());

        self.allocate_memory(program)?;
        self.generate_startup_routine(program)?;

        for decl in &program.declarations {
            self.generate_top_level(decl)?;
        }

        self.generate_sound_engine();
        self.generate_math_helpers();
        self.generate_string_data();
        self.generate_user_data(program)?;
        self.generate_data_tables(program)?;
        self.generate_vectors(program)?;

        Ok(self.output.clone())
    }

    fn get_type_size(&self, dt: &DataType) -> u16 {
        match dt {
            DataType::Byte | DataType::Int | DataType::Bool => 1,
            DataType::Word | DataType::String => 2,
            DataType::Struct(name) => {
                if let Some(sym) = self.symbol_table.resolve(name) {
                    if let Some(size) = sym.value {
                        return size as u16;
                    }
                }
                0
            }
            DataType::Array(inner, size) => self.get_type_size(inner) * (*size as u16),
        }
    }

    fn generate_startup_routine(&mut self, program: &Program) -> Result<(), String> {
        self.output.push("Startup:".to_string());
        self.output.push("  SEI".to_string());
        self.output.push("  CLD".to_string());
        self.output.push("  LDX #$40".to_string());
        self.output.push("  STX $4017".to_string());
        self.output.push("  LDX #$FF".to_string());
        self.output.push("  TXS".to_string());
        self.output.push("  INX".to_string());
        self.output.push("  STX $2000".to_string());
        self.output.push("  STX $2001".to_string());
        self.output.push("  STX $4010".to_string());

        self.output.push("vblankwait1:".to_string());
        self.output.push("  BIT $2002".to_string());
        self.output.push("  BPL vblankwait1".to_string());

        self.output.push("clrmem:".to_string());
        self.output.push("  LDA #$00".to_string());
        self.output.push("  STA $00,x".to_string());
        self.output.push("  STA $0100,x".to_string());
        self.output.push("  STA $0300,x".to_string());
        self.output.push("  STA $0400,x".to_string());
        self.output.push("  STA $0500,x".to_string());
        self.output.push("  STA $0600,x".to_string());
        self.output.push("  STA $0700,x".to_string());
        self.output.push("  LDA #$FE".to_string());
        self.output.push("  STA $0200,x".to_string());
        self.output.push("  INX".to_string());
        self.output.push("  BNE clrmem".to_string());

        self.output.push("vblankwait2:".to_string());
        self.output.push("  BIT $2002".to_string());
        self.output.push("  BPL vblankwait2".to_string());

        self.output.push("  LDA #$3F".to_string());
        self.output.push("  STA $2006".to_string());
        self.output.push("  LDA #$00".to_string());
        self.output.push("  STA $2006".to_string());

        self.output.push("  LDX #$00".to_string());
        self.output.push("LoadPalLoop:".to_string());
        self.output.push("  LDA $E000, X".to_string());
        self.output.push("  STA $2007".to_string());
        self.output.push("  INX".to_string());
        self.output.push("  CPX #32".to_string());
        self.output.push("  BNE LoadPalLoop".to_string());

        self.output.push("  LDA #$20".to_string());
        self.output.push("  STA $2006".to_string());
        self.output.push("  LDA #$00".to_string());
        self.output.push("  STA $2006".to_string());

        self.output.push("  LDX #$00".to_string());
        self.output.push("LoadNT1:".to_string());
        self.output
            .push(format!("  LDA ${:04X}, X", NAMETABLE_ADDR));
        self.output.push("  STA $2007".to_string());
        self.output.push("  INX".to_string());
        self.output.push("  BNE LoadNT1".to_string());

        self.output.push("  LDX #$00".to_string());
        self.output.push("LoadNT2:".to_string());
        self.output
            .push(format!("  LDA ${:04X}, X", NAMETABLE_ADDR + 256));
        self.output.push("  STA $2007".to_string());
        self.output.push("  INX".to_string());
        self.output.push("  BNE LoadNT2".to_string());

        self.output.push("  LDX #$00".to_string());
        self.output.push("LoadNT3:".to_string());
        self.output
            .push(format!("  LDA ${:04X}, X", NAMETABLE_ADDR + 512));
        self.output.push("  STA $2007".to_string());
        self.output.push("  INX".to_string());
        self.output.push("  BNE LoadNT3".to_string());

        self.output.push("  LDX #$00".to_string());
        self.output.push("LoadNT4:".to_string());
        self.output
            .push(format!("  LDA ${:04X}, X", NAMETABLE_ADDR + 768));
        self.output.push("  STA $2007".to_string());
        self.output.push("  INX".to_string());
        self.output.push("  BNE LoadNT4".to_string());

        self.output.push("  JSR Sound_Init".to_string());

        if let Some(addr) = self.data_table_offsets.get("USER_DATA_START") {
            self.output.push(format!("  LDA ${:04X}", addr));
            self.output.push("  STA $04".to_string());
            self.output.push(format!("  LDA ${:04X}", addr + 1));
            self.output.push("  STA $05".to_string());
        }

        self.output.push("  JSR Main".to_string());

        let nmi_label = program.declarations.iter().find_map(|d| {
            if let TopLevel::Interrupt(name, _) = d {
                if name.to_uppercase() == "NMI" {
                    return Some(name.clone());
                }
            }
            None
        });

        let irq_label = program.declarations.iter().find_map(|d| {
            if let TopLevel::Interrupt(name, _) = d {
                if name.to_uppercase() == "IRQ" {
                    return Some(name.clone());
                }
            }
            None
        });

        let mut current_addr = 0xFF00;
        let addr_default_rti = current_addr;
        current_addr += 2;
        let mut init_nmi_addr: Option<u16> = None;
        let mut init_irq_addr: Option<u16> = None;

        for decl in &program.declarations {
            if let TopLevel::Interrupt(name, _) = decl {
                let upper = name.to_uppercase();
                if upper == "NMI" {
                    init_nmi_addr = Some(current_addr);
                    current_addr += 2;
                } else if upper == "IRQ" {
                    init_irq_addr = Some(current_addr);
                    current_addr += 2;
                }
                current_addr += 2;
            }
            if let TopLevel::Sub(_, _, _) = decl {
                current_addr += 2;
            }
        }

        if nmi_label.is_some() {
            if let Some(addr) = init_nmi_addr {
                self.output.push(format!("  LDA ${:04X}", addr));
                self.output.push("  STA $03FA".to_string());
                self.output.push(format!("  LDA ${:04X}", addr + 1));
                self.output.push("  STA $03FB".to_string());
            }
        } else {
            self.output.push(format!("  LDA ${:04X}", addr_default_rti));
            self.output.push("  STA $03FA".to_string());
            self.output
                .push(format!("  LDA ${:04X}", addr_default_rti + 1));
            self.output.push("  STA $03FB".to_string());
        }

        if irq_label.is_some() {
            if let Some(addr) = init_irq_addr {
                self.output.push(format!("  LDA ${:04X}", addr));
                self.output.push("  STA $03FC".to_string());
                self.output.push(format!("  LDA ${:04X}", addr + 1));
                self.output.push("  STA $03FD".to_string());
            }
        } else {
            self.output.push(format!("  LDA ${:04X}", addr_default_rti));
            self.output.push("  STA $03FC".to_string());
            self.output
                .push(format!("  LDA ${:04X}", addr_default_rti + 1));
            self.output.push("  STA $03FD".to_string());
        }

        for decl in &program.declarations {
            if let TopLevel::Dim(name, DataType::String, Some(Expression::StringLiteral(val))) =
                decl
            {
                if let Some(label) = self.string_literals.get(val) {
                    if let Some(addr) = self.data_table_offsets.get(label) {
                        if let Some(sym) = self.symbol_table.resolve(name) {
                            if let Some(var_addr) = sym.address {
                                self.output.push(format!("  ; Init String '{}'", name));
                                self.output.push(format!("  LDA ${:04X}", addr));
                                self.output.push(format!("  STA ${:04X}", var_addr));
                                self.output.push(format!("  LDA ${:04X}", addr + 1));
                                self.output.push(format!("  STA ${:04X}", var_addr + 1));
                            }
                        }
                    }
                }
            }
        }

        self.output.push("forever:".to_string());
        self.output.push("  JMP forever".to_string());
        self.output.push("".to_string());
        self.output.push("DefaultRTI:".to_string());
        self.output.push("  RTI".to_string());
        self.output.push("".to_string());
        self.output.push("TrampolineNMI:".to_string());
        self.output.push("  JSR Sound_Update".to_string());
        self.output.push("  JMP ($03FA)".to_string());
        self.output.push("TrampolineIRQ:".to_string());
        self.output.push("  JMP ($03FC)".to_string());
        self.output.push("".to_string());

        Ok(())
    }

    fn generate_sound_engine(&mut self) {
        // ... (Sound Engine Content - assuming no changes needed here, just keep existing)
        // For brevity I will assume I can keep the existing code, but I am overwriting the file.
        // I MUST include the full sound engine code.
        // I'll copy it from previous read.

        self.output.push("; --- Sound Engine ---".to_string());
        self.output.push("Sound_Init:".to_string());
        self.output.push("  LDA #$0F".to_string());
        self.output.push("  STA $4015".to_string());
        self.output.push("  LDX #$00".to_string());
        self.output.push("  LDA #$00".to_string());
        self.output.push("SndClear:".to_string());
        self.output.push("  STA $02E0, X".to_string());
        self.output.push("  INX".to_string());
        self.output.push("  CPX #$10".to_string());
        self.output.push("  BNE SndClear".to_string());
        self.output.push("  RTS".to_string());

        self.output.push("Sound_Play:".to_string());
        self.output.push("  PHA".to_string());
        self.output.push("  LDA $D100".to_string());
        self.output.push("  STA $F0".to_string());
        self.output.push("  PLA".to_string());
        self.output.push("  CMP $F0".to_string());
        self.output.push("  BCS SndPlayEnd".to_string());
        self.output.push("  ASL".to_string());
        self.output.push("  TAX".to_string());
        self.output.push("  LDA $D101, X".to_string());
        self.output.push("  STA $F0".to_string());
        self.output.push("  LDA $D102, X".to_string());
        self.output.push("  STA $F1".to_string());
        self.output.push("  LDY #$00".to_string());
        self.output.push("  LDA ($F0), Y".to_string());
        self.output.push("  AND #$03".to_string());
        self.output.push("  STA $F2".to_string());
        self.output.push("  INC $F0".to_string());
        self.output.push("  BNE SndPtrInc1".to_string());
        self.output.push("  INC $F1".to_string());
        self.output.push("SndPtrInc1:".to_string());
        self.output.push("  LDA ($F0), Y".to_string());
        self.output.push("  STA $F3".to_string());
        self.output.push("  INC $F0".to_string());
        self.output.push("  BNE SndPtrInc2".to_string());
        self.output.push("  INC $F1".to_string());
        self.output.push("SndPtrInc2:".to_string());
        self.output.push("  LDA $F2".to_string());
        self.output.push("  ASL".to_string());
        self.output.push("  ASL".to_string());
        self.output.push("  TAX".to_string());
        self.output.push("  LDY $F2".to_string());
        self.output.push("  LDA $F3".to_string());
        self.output.push("  STA $02F0, Y".to_string());
        self.output.push("  LDA #$01".to_string());
        self.output.push("  STA $02E0, X".to_string());
        self.output.push("  LDA #$01".to_string());
        self.output.push("  STA $02E1, X".to_string());
        self.output.push("  LDA $F0".to_string());
        self.output.push("  STA $02E2, X".to_string());
        self.output.push("  LDA $F1".to_string());
        self.output.push("  STA $02E3, X".to_string());
        self.output.push("SndPlayEnd:".to_string());
        self.output.push("  RTS".to_string());

        self.output.push("Sound_Update:".to_string());
        self.output.push("  PHA".to_string());
        self.output.push("  TXA".to_string());
        self.output.push("  PHA".to_string());
        self.output.push("  TYA".to_string());
        self.output.push("  PHA".to_string());
        self.output.push("  LDX #$00".to_string());
        self.output.push("  JSR SndChUpdate".to_string());
        self.output.push("  LDX #$04".to_string());
        self.output.push("  JSR SndChUpdate".to_string());
        self.output.push("  LDX #$08".to_string());
        self.output.push("  JSR SndChUpdate".to_string());
        self.output.push("  PLA".to_string());
        self.output.push("  TAY".to_string());
        self.output.push("  PLA".to_string());
        self.output.push("  TAX".to_string());
        self.output.push("  PLA".to_string());
        self.output.push("  RTS".to_string());

        self.output.push("SndChUpdate:".to_string());
        self.output.push("  LDA $02E0, X".to_string());
        self.output.push("  BNE SndActive".to_string());
        self.output.push("  RTS".to_string());
        self.output.push("SndActive:".to_string());
        self.output.push("  DEC $02E1, X".to_string());
        self.output.push("  BEQ SndTimerExpired".to_string());
        self.output.push("  RTS".to_string());
        self.output.push("SndTimerExpired:".to_string());
        self.output.push("  LDA $02E2, X".to_string());
        self.output.push("  STA $F4".to_string());
        self.output.push("  LDA $02E3, X".to_string());
        self.output.push("  STA $F5".to_string());
        self.output.push("  LDY #$00".to_string());
        self.output.push("  LDA ($F4), Y".to_string());
        self.output.push("  CMP #$00".to_string());
        self.output.push("  BNE SndNextNote".to_string());
        self.output.push("  STA $02E0, X".to_string());
        self.output.push("  CPX #$00".to_string());
        self.output.push("  BEQ SilenceP1".to_string());
        self.output.push("  CPX #$04".to_string());
        self.output.push("  BEQ SilenceP2".to_string());
        self.output.push("  CPX #$08".to_string());
        self.output.push("  BEQ SilenceTri".to_string());
        self.output.push("  JMP SndChEnd".to_string());
        self.output.push("SilenceP1:".to_string());
        self.output.push("  LDA #$30".to_string());
        self.output.push("  STA $4000".to_string());
        self.output.push("  JMP SndChEnd".to_string());
        self.output.push("SilenceP2:".to_string());
        self.output.push("  LDA #$30".to_string());
        self.output.push("  STA $4004".to_string());
        self.output.push("  JMP SndChEnd".to_string());
        self.output.push("SilenceTri:".to_string());
        self.output.push("  LDA #$80".to_string());
        self.output.push("  STA $4008".to_string());
        self.output.push("  JMP SndChEnd".to_string());
        self.output.push("SndNextNote:".to_string());
        self.output.push("  STA $02E1, X".to_string());
        self.output.push("  INC $F4".to_string());
        self.output.push("  BNE SndPtrInc3".to_string());
        self.output.push("  INC $F5".to_string());
        self.output.push("SndPtrInc3:".to_string());
        self.output.push("  LDA ($F4), Y".to_string());
        self.output.push("  CMP #$FF".to_string());
        self.output.push("  BEQ SndPlaySilence".to_string());
        self.output.push("  ASL".to_string());
        self.output.push("  TAY".to_string());
        self.output.push("  LDA $D000, Y".to_string());
        self.output.push("  STA $F6".to_string());
        self.output.push("  LDA $D001, Y".to_string());
        self.output.push("  STA $F7".to_string());
        self.output.push("  CPX #$00".to_string());
        self.output.push("  BEQ PlayP1".to_string());
        self.output.push("  CPX #$04".to_string());
        self.output.push("  BEQ PlayP2".to_string());
        self.output.push("  CPX #$08".to_string());
        self.output.push("  BEQ PlayTri".to_string());
        self.output.push("  JMP SndAdvance".to_string());
        self.output.push("SndPlaySilence:".to_string());
        self.output.push("  CPX #$00".to_string());
        self.output.push("  BEQ SilenceP1".to_string());
        self.output.push("  CPX #$04".to_string());
        self.output.push("  BEQ SilenceP2".to_string());
        self.output.push("  CPX #$08".to_string());
        self.output.push("  BEQ SilenceTri".to_string());
        self.output.push("  JMP SndAdvance".to_string());
        self.output.push("PlayP1:".to_string());
        self.output.push("  LDA $02F0".to_string());
        self.output.push("  STA $4000".to_string());
        self.output.push("  LDA $F6".to_string());
        self.output.push("  STA $4002".to_string());
        self.output.push("  LDA $F7".to_string());
        self.output.push("  STA $4003".to_string());
        self.output.push("  JMP SndAdvance".to_string());
        self.output.push("PlayP2:".to_string());
        self.output.push("  LDA $02F1".to_string());
        self.output.push("  STA $4004".to_string());
        self.output.push("  LDA $F6".to_string());
        self.output.push("  STA $4006".to_string());
        self.output.push("  LDA $F7".to_string());
        self.output.push("  STA $4007".to_string());
        self.output.push("  JMP SndAdvance".to_string());
        self.output.push("PlayTri:".to_string());
        self.output.push("  LDA #$FF".to_string());
        self.output.push("  STA $4008".to_string());
        self.output.push("  LDA $F6".to_string());
        self.output.push("  STA $400A".to_string());
        self.output.push("  LDA $F7".to_string());
        self.output.push("  STA $400B".to_string());
        self.output.push("SndAdvance:".to_string());
        self.output.push("  INC $F4".to_string());
        self.output.push("  BNE SndPtrInc3".to_string());
        self.output.push("  INC $F5".to_string());
        self.output.push("SndPtrInc3:".to_string());
        self.output.push("  LDA $F4".to_string());
        self.output.push("  STA $02E2, X".to_string());
        self.output.push("  LDA $F5".to_string());
        self.output.push("  STA $02E3, X".to_string());
        self.output.push("SndChEnd:".to_string());
        self.output.push("  RTS".to_string());
    }

    fn generate_math_helpers(&mut self) {
        // ... (Keep existing helpers: Mul8, Div8, Mul16, Div16, Div16_Signed, ReadByte, ReadString)
        self.output.push("; --- Math Helpers ---".to_string());

        self.output.push("Math_Mul8:".to_string());
        self.output.push("  STA $01".to_string());
        self.output.push("  LDA #0".to_string());
        self.output.push("  LDX #8".to_string());
        self.output.push("Math_MulLoop:".to_string());
        self.output.push("  ASL".to_string());
        self.output.push("  ASL $01".to_string());
        self.output.push("  BCC Math_MulNoAdd".to_string());
        self.output.push("  CLC".to_string());
        self.output.push("  ADC $00".to_string());
        self.output.push("Math_MulNoAdd:".to_string());
        self.output.push("  DEX".to_string());
        self.output.push("  BNE Math_MulLoop".to_string());
        self.output.push("  RTS".to_string());

        self.output.push("Math_Div8:".to_string());
        self.output.push("  STA $02".to_string());
        self.output.push("  LDA #0".to_string());
        self.output.push("  STA $01".to_string());
        self.output.push("  LDX #8".to_string());
        self.output.push("Math_DivLoop:".to_string());
        self.output.push("  ASL $02".to_string());
        self.output.push("  ROL".to_string());
        self.output.push("  CMP $00".to_string());
        self.output.push("  BCC Math_DivSkip".to_string());
        self.output.push("  SBC $00".to_string());
        self.output.push("  INC $02".to_string());
        self.output.push("Math_DivSkip:".to_string());
        self.output.push("  DEX".to_string());
        self.output.push("  BNE Math_DivLoop".to_string());
        self.output.push("  STA $01".to_string());
        self.output.push("  LDA $02".to_string());
        self.output.push("  RTS".to_string());

        self.output.push("Math_Mul16:".to_string());
        self.output.push("  STA $06".to_string());
        self.output.push("  STX $07".to_string());
        self.output.push("  LDA #0".to_string());
        self.output.push("  STA $08".to_string());
        self.output.push("  STA $09".to_string());
        self.output.push("  LDY #16".to_string());
        self.output.push("Math_Mul16Loop:".to_string());
        self.output.push("  ASL $08".to_string());
        self.output.push("  ROL $09".to_string());
        self.output.push("  ASL $06".to_string());
        self.output.push("  ROL $07".to_string());
        self.output.push("  BCC Math_Mul16NoAdd".to_string());
        self.output.push("  CLC".to_string());
        self.output.push("  LDA $08".to_string());
        self.output.push("  ADC $00".to_string());
        self.output.push("  STA $08".to_string());
        self.output.push("  LDA $09".to_string());
        self.output.push("  ADC $01".to_string());
        self.output.push("  STA $09".to_string());
        self.output.push("Math_Mul16NoAdd:".to_string());
        self.output.push("  DEY".to_string());
        self.output.push("  BNE Math_Mul16Loop".to_string());
        self.output.push("  LDA $08".to_string());
        self.output.push("  LDX $09".to_string());
        self.output.push("  RTS".to_string());

        self.output.push("Math_Div16:".to_string());
        self.output.push("  STA $06".to_string());
        self.output.push("  STX $07".to_string());
        self.output.push("  LDA #0".to_string());
        self.output.push("  STA $08".to_string());
        self.output.push("  STA $09".to_string());
        self.output.push("  LDY #16".to_string());
        self.output.push("Math_Div16Loop:".to_string());
        self.output.push("  ASL $06".to_string());
        self.output.push("  ROL $07".to_string());
        self.output.push("  ROL $08".to_string());
        self.output.push("  ROL $09".to_string());
        self.output.push("  SEC".to_string());
        self.output.push("  LDA $08".to_string());
        self.output.push("  SBC $00".to_string());
        self.output.push("  PHA".to_string());
        self.output.push("  LDA $09".to_string());
        self.output.push("  SBC $01".to_string());
        self.output.push("  BCC Math_Div16Skip".to_string());
        self.output.push("  STA $09".to_string());
        self.output.push("  PLA".to_string());
        self.output.push("  STA $08".to_string());
        self.output.push("  INC $06".to_string());
        self.output.push("  JMP Math_Div16Next".to_string());
        self.output.push("Math_Div16Skip:".to_string());
        self.output.push("  PLA".to_string());
        self.output.push("Math_Div16Next:".to_string());
        self.output.push("  DEY".to_string());
        self.output.push("  BNE Math_Div16Loop".to_string());
        self.output.push("  LDA $06".to_string());
        self.output.push("  LDX $07".to_string());
        self.output.push("  RTS".to_string());

        self.output.push("Runtime_ReadByte:".to_string());
        self.output.push("  LDY #0".to_string());
        self.output.push("  LDA ($04), Y".to_string());
        self.output.push("  INC $04".to_string());
        self.output.push("  BNE Runtime_ReadByte_Done".to_string());
        self.output.push("  INC $05".to_string());
        self.output.push("Runtime_ReadByte_Done:".to_string());
        self.output.push("  RTS".to_string());

        self.output.push("Runtime_ReadString:".to_string());
        self.output.push("  LDA $04".to_string());
        self.output.push("  LDX $05".to_string());
        self.output.push("  PHA".to_string());
        self.output.push("  TXA".to_string());
        self.output.push("  PHA".to_string());
        self.output.push("  LDY #0".to_string());
        self.output.push("Runtime_ReadString_Loop:".to_string());
        self.output.push("  LDA ($04), Y".to_string());
        self.output.push("  INC $04".to_string());
        self.output
            .push("  BNE Runtime_ReadString_NoWrap".to_string());
        self.output.push("  INC $05".to_string());
        self.output.push("Runtime_ReadString_NoWrap:".to_string());
        self.output.push("  CMP #0".to_string());
        self.output
            .push("  BNE Runtime_ReadString_Loop".to_string());
        self.output.push("  PLA".to_string());
        self.output.push("  TAX".to_string());
        self.output.push("  PLA".to_string());
        self.output.push("  RTS".to_string());

        self.output.push("Math_Div16_Signed:".to_string());
        self.output.push("  STA $06".to_string());
        self.output.push("  STX $07".to_string());
        self.output.push("  STX $0B".to_string());
        self.output.push("  LDA $01".to_string());
        self.output.push("  STA $0C".to_string());
        self.output.push("  EOR $0B".to_string());
        self.output.push("  STA $0A".to_string());
        self.output.push("  LDA $06".to_string());
        self.output.push("  LDX $07".to_string());
        self.output.push("  LDY $0B".to_string());
        self.output
            .push("  BPL Math_DivSigned_AbsDivisor".to_string());
        self.output.push("  EOR #$FF".to_string());
        self.output.push("  CLC".to_string());
        self.output.push("  ADC #1".to_string());
        self.output.push("  PHA".to_string());
        self.output.push("  TXA".to_string());
        self.output.push("  EOR #$FF".to_string());
        self.output.push("  ADC #0".to_string());
        self.output.push("  TAX".to_string());
        self.output.push("  PLA".to_string());
        self.output.push("Math_DivSigned_AbsDivisor:".to_string());
        self.output.push("  PHA".to_string());
        self.output.push("  TXA".to_string());
        self.output.push("  PHA".to_string());
        self.output.push("  LDA $0C".to_string());
        self.output.push("  BPL Math_DivSigned_Do".to_string());
        self.output.push("  LDA $00".to_string());
        self.output.push("  EOR #$FF".to_string());
        self.output.push("  CLC".to_string());
        self.output.push("  ADC #1".to_string());
        self.output.push("  STA $00".to_string());
        self.output.push("  LDA $01".to_string());
        self.output.push("  EOR #$FF".to_string());
        self.output.push("  ADC #0".to_string());
        self.output.push("  STA $01".to_string());
        self.output.push("Math_DivSigned_Do:".to_string());
        self.output.push("  PLA".to_string());
        self.output.push("  TAX".to_string());
        self.output.push("  PLA".to_string());
        self.output.push("  JSR Math_Div16".to_string());
        self.output.push("  LDY $0A".to_string());
        self.output
            .push("  BPL Math_DivSigned_CheckRem".to_string());
        self.output.push("  EOR #$FF".to_string());
        self.output.push("  CLC".to_string());
        self.output.push("  ADC #1".to_string());
        self.output.push("  PHA".to_string());
        self.output.push("  TXA".to_string());
        self.output.push("  EOR #$FF".to_string());
        self.output.push("  ADC #0".to_string());
        self.output.push("  TAX".to_string());
        self.output.push("  PLA".to_string());
        self.output.push("Math_DivSigned_CheckRem:".to_string());
        self.output.push("  LDY $0B".to_string());
        self.output.push("  BPL Math_DivSigned_Done".to_string());
        self.output.push("  PHA".to_string());
        self.output.push("  TXA".to_string());
        self.output.push("  PHA".to_string());
        self.output.push("  LDA $08".to_string());
        self.output.push("  EOR #$FF".to_string());
        self.output.push("  CLC".to_string());
        self.output.push("  ADC #1".to_string());
        self.output.push("  STA $08".to_string());
        self.output.push("  LDA $09".to_string());
        self.output.push("  EOR #$FF".to_string());
        self.output.push("  ADC #0".to_string());
        self.output.push("  STA $09".to_string());
        self.output.push("  PLA".to_string());
        self.output.push("  TAX".to_string());
        self.output.push("  PLA".to_string());
        self.output.push("Math_DivSigned_Done:".to_string());
        self.output.push("  RTS".to_string());
    }

    fn generate_string_data(&mut self) {
        self.output.push("".to_string());
        self.output.push("; --- String Data ---".to_string());
        for (content, label) in &self.string_literals {
            self.output.push(format!("{}:", label));
            let bytes: Vec<String> = content.bytes().map(|b| format!("${:02X}", b)).collect();
            self.output.push(format!("  db {}, $00", bytes.join(", ")));
        }
        self.output.push("".to_string());
    }

    fn generate_user_data(&mut self, program: &Program) -> Result<(), String> {
        self.output.push("".to_string());
        self.output.push("; --- User Data ---".to_string());
        self.output.push("USER_DATA_START:".to_string());
        for decl in &program.declarations {
            if let TopLevel::Data(label, exprs) = decl {
                if let Some(l) = label {
                    self.output.push(format!("{}:", l));
                }
                for expr in exprs {
                    match expr {
                        Expression::Integer(val) => {
                            if (-128..=255).contains(val) {
                                self.output
                                    .push(format!("  db ${:02X}", (val & 0xFF) as u8));
                            } else {
                                let low = (val & 0xFF) as u8;
                                let high = ((val >> 8) & 0xFF) as u8;
                                self.output
                                    .push(format!("  db ${:02X}, ${:02X}", low, high));
                            }
                        }
                        Expression::StringLiteral(s) => {
                            let bytes: Vec<String> =
                                s.bytes().map(|b| format!("${:02X}", b)).collect();
                            self.output.push(format!("  db {}, $00", bytes.join(", ")));
                        }
                        Expression::UnaryOp(UnaryOperator::Negate, operand) => {
                            if let Expression::Integer(val) = **operand {
                                let neg_val = -val;
                                if (-128..=255).contains(&neg_val) {
                                    self.output
                                        .push(format!("  db ${:02X}", (neg_val & 0xFF) as u8));
                                } else {
                                    let low = (neg_val & 0xFF) as u8;
                                    let high = ((neg_val >> 8) & 0xFF) as u8;
                                    self.output
                                        .push(format!("  db ${:02X}, ${:02X}", low, high));
                                }
                            } else {
                                return Err("DATA error".to_string());
                            }
                        }
                        _ => return Err("DATA statement only supports literals".to_string()),
                    }
                }
            }
        }
        self.output.push("".to_string());
        Ok(())
    }

    fn generate_data_tables(&mut self, program: &Program) -> Result<(), String> {
        self.output.push("".to_string());
        self.output.push("; --- Data Tables ---".to_string());
        self.output.push(".ORG $FF00".to_string());
        let mut current_addr = 0xFF00;
        self.output
            .push("InitDefaultRTI: WORD DefaultRTI".to_string());
        current_addr += 2;
        self.output
            .push("InitUserData: WORD USER_DATA_START".to_string());
        current_addr += 2;

        for decl in &program.declarations {
            if let TopLevel::Interrupt(name, _) = decl {
                let upper = name.to_uppercase();
                if upper == "NMI" {
                    self.output.push(format!("InitNMI_{}: WORD {}", name, name));
                    current_addr += 2;
                } else if upper == "IRQ" {
                    self.output.push(format!("InitIRQ_{}: WORD {}", name, name));
                    current_addr += 2;
                }
                self.output.push(format!("Ptr_{}: WORD {}", name, name));
                self.data_table_offsets.insert(name.clone(), current_addr);
                current_addr += 2;
            }
            if let TopLevel::Sub(name, _, _) = decl {
                self.output.push(format!("Ptr_{}: WORD {}", name, name));
                self.data_table_offsets.insert(name.clone(), current_addr);
                current_addr += 2;
            }
            if let TopLevel::Data(Some(label), _) = decl {
                self.output.push(format!("Ptr_{}: WORD {}", label, label));
                self.data_table_offsets.insert(label.clone(), current_addr);
                current_addr += 2;
            }
        }

        let mut sorted_strings: Vec<_> = self.string_literals.iter().collect();
        sorted_strings.sort_by_key(|(k, _)| *k);
        for (_, label) in sorted_strings {
            self.output.push(format!("Ptr_{}: WORD {}", label, label));
        }
        self.output.push("".to_string());
        Ok(())
    }

    fn generate_vectors(&mut self, _program: &Program) -> Result<(), String> {
        self.output.push("".to_string());
        self.output.push(".ORG $FFFA".to_string());
        self.output.push("VecNMI: WORD TrampolineNMI".to_string());
        self.output.push("VecReset: WORD Startup".to_string());
        self.output.push("VecIRQ: WORD TrampolineIRQ".to_string());
        self.output.push("".to_string());
        Ok(())
    }

    fn collect_all_strings(&mut self, program: &Program) {
        for decl in &program.declarations {
            match decl {
                TopLevel::Const(_, expr) => self.collect_strings_expr(expr),
                TopLevel::Dim(_, _, Some(expr)) => self.collect_strings_expr(expr),
                TopLevel::Sub(_, _, body) => self.collect_strings_block(body),
                TopLevel::Interrupt(_, body) => self.collect_strings_block(body),
                TopLevel::Data(_, exprs) => {
                    for e in exprs {
                        self.collect_strings_expr(e);
                    }
                }
                _ => {}
            }
        }
    }

    fn collect_strings_block(&mut self, statements: &[Statement]) {
        for stmt in statements {
            self.collect_strings_stmt(stmt);
        }
    }

    fn collect_strings_stmt(&mut self, stmt: &Statement) {
        match stmt {
            Statement::Let(target, expr) => {
                self.collect_strings_expr(target);
                self.collect_strings_expr(expr);
            }
            Statement::If(cond, then_b, else_b) => {
                self.collect_strings_expr(cond);
                self.collect_strings_block(then_b);
                if let Some(b) = else_b {
                    self.collect_strings_block(b);
                }
            }
            Statement::While(cond, body) => {
                self.collect_strings_expr(cond);
                self.collect_strings_block(body);
            }
            Statement::DoWhile(body, cond) => {
                self.collect_strings_block(body);
                self.collect_strings_expr(cond);
            }
            Statement::For(_, start, end, step, body) => {
                self.collect_strings_expr(start);
                self.collect_strings_expr(end);
                if let Some(s) = step {
                    self.collect_strings_expr(s);
                }
                self.collect_strings_block(body);
            }
            Statement::Return(Some(expr)) => self.collect_strings_expr(expr),
            Statement::Call(target, args) => {
                self.collect_strings_expr(target);
                for arg in args {
                    self.collect_strings_expr(arg);
                }
            }
            Statement::Poke(addr, val) => {
                self.collect_strings_expr(addr);
                self.collect_strings_expr(val);
            }
            Statement::PlaySfx(expr) => self.collect_strings_expr(expr),
            Statement::Select(expr, cases, else_b) => {
                self.collect_strings_expr(expr);
                for (val, block) in cases {
                    self.collect_strings_expr(val);
                    self.collect_strings_block(block);
                }
                if let Some(b) = else_b {
                    self.collect_strings_block(b);
                }
            }
            _ => {}
        }
    }

    fn collect_strings_expr(&mut self, expr: &Expression) {
        match expr {
            Expression::StringLiteral(s) => {
                if !self.string_literals.contains_key(s) {
                    let label = self.new_label();
                    self.string_literals.insert(s.clone(), label);
                }
            }
            Expression::BinaryOp(l, _, r) => {
                self.collect_strings_expr(l);
                self.collect_strings_expr(r);
            }
            Expression::UnaryOp(_, e) => self.collect_strings_expr(e),
            Expression::Call(target, args) => {
                self.collect_strings_expr(target);
                for arg in args {
                    self.collect_strings_expr(arg);
                }
            }
            Expression::Peek(e) => self.collect_strings_expr(e),
            Expression::MemberAccess(e, _) => self.collect_strings_expr(e),
            _ => {}
        }
    }

    fn allocate_memory(&mut self, program: &Program) -> Result<(), String> {
        self.collect_all_strings(program);
        self.ram_pointer = 0x0300;
        let mut data_table_addr = 0xFF00;
        data_table_addr += 2; // InitDefaultRTI
        self.data_table_offsets
            .insert("USER_DATA_START".to_string(), data_table_addr);
        data_table_addr += 2;

        for decl in &program.declarations {
            match decl {
                TopLevel::Dim(name, dtype, _) => {
                    self.symbol_table.assign_address(name, self.ram_pointer)?;
                    self.output
                        .push(format!("; {} @ ${:04X}", name, self.ram_pointer));
                    let size = self.get_type_size(dtype);
                    self.ram_pointer += size;
                }
                TopLevel::Sub(sub_name, params, _) => {
                    self.symbol_table.enter_scope();
                    let mut sig_params = Vec::new();
                    for (param_name, param_type) in params {
                        self.symbol_table.define(
                            param_name.clone(),
                            param_type.clone(),
                            SymbolKind::Param,
                        )?;
                        self.symbol_table
                            .assign_address(param_name, self.ram_pointer)?;
                        self.output.push(format!(
                            "; {}.{} @ ${:04X}",
                            sub_name, param_name, self.ram_pointer
                        ));
                        sig_params.push((self.ram_pointer, param_type.clone()));
                        self.ram_pointer += self.get_type_size(param_type);
                    }
                    self.sub_signatures.insert(sub_name.clone(), sig_params);
                    self.data_table_offsets
                        .insert(sub_name.clone(), data_table_addr);
                    data_table_addr += 2;
                    self.symbol_table.exit_scope();
                }
                TopLevel::Interrupt(name, _) => {
                    if name.to_uppercase() == "NMI" || name.to_uppercase() == "IRQ" {
                        data_table_addr += 2;
                    }
                    self.data_table_offsets
                        .insert(name.clone(), data_table_addr);
                    data_table_addr += 2;
                }
                TopLevel::Data(Some(label), _) => {
                    self.data_table_offsets
                        .insert(label.clone(), data_table_addr);
                    data_table_addr += 2;
                }
                _ => {}
            }
        }
        let mut sorted_strings: Vec<_> = self.string_literals.iter().collect();
        sorted_strings.sort_by_key(|(k, _)| *k);
        for (_, label) in sorted_strings {
            if !self.data_table_offsets.contains_key(label) {
                self.data_table_offsets
                    .insert(label.clone(), data_table_addr);
                data_table_addr += 2;
            }
        }
        Ok(())
    }

    fn generate_top_level(&mut self, decl: &TopLevel) -> Result<(), String> {
        match decl {
            TopLevel::Sub(name, _, body) => {
                self.output.push(format!("{}:", name));
                self.symbol_table.enter_scope();
                self.generate_block(body)?;
                self.symbol_table.exit_scope();
                self.output.push("  RTS".to_string());
                self.output.push("".to_string());
            }
            TopLevel::Interrupt(name, body) => {
                self.output.push(format!("{}:", name));
                self.symbol_table.enter_scope();
                self.generate_block(body)?;
                self.symbol_table.exit_scope();
                self.output.push("  RTI".to_string());
                self.output.push("".to_string());
            }
            TopLevel::Asm(lines) => {
                for line in lines {
                    self.output.push(format!("  {}", line));
                }
            }
            _ => {}
        }
        Ok(())
    }

    fn generate_block(&mut self, statements: &[Statement]) -> Result<(), String> {
        for stmt in statements {
            self.generate_statement(stmt)?;
        }
        Ok(())
    }

    fn generate_statement(&mut self, stmt: &Statement) -> Result<(), String> {
        match stmt {
            Statement::Let(target, expr) => {
                // If target is Array Access, we need special handling
                if let Expression::Call(callee, args) = target {
                    // Array Assignment
                    // 1. Calculate Value
                    let rtype = self.generate_expression(expr)?;
                    // Save Value to Stack
                    if rtype == DataType::Byte || rtype == DataType::Bool || rtype == DataType::Int
                    {
                        self.output.push("  PHA".to_string());
                    } else {
                        self.output.push("  PHA".to_string()); // Low
                        self.output.push("  TXA".to_string());
                        self.output.push("  PHA".to_string()); // High
                    }

                    // 2. Calculate Address -> $02/$03
                    self.generate_array_address(callee, &args[0])?;

                    // 3. Restore Value and Store
                    if rtype == DataType::Byte || rtype == DataType::Bool || rtype == DataType::Int
                    {
                        self.output.push("  PLA".to_string());
                        self.output.push("  LDY #0".to_string());
                        self.output.push("  STA ($02),Y".to_string());
                    } else {
                        // Word/String
                        self.output.push("  PLA".to_string()); // High
                        self.output.push("  TAX".to_string());
                        self.output.push("  PLA".to_string()); // Low
                        self.output.push("  LDY #0".to_string());
                        self.output.push("  STA ($02),Y".to_string());
                        self.output.push("  TXA".to_string());
                        self.output.push("  INY".to_string());
                        self.output.push("  STA ($02),Y".to_string());
                    }
                    return Ok(());
                }

                let addr = self.get_static_address(target)?;
                let target_type = self.resolve_type(target).ok_or("Unknown target type")?;

                match target_type {
                    DataType::Word => match expr {
                        Expression::Integer(val) => {
                            let low = (val & 0xFF) as u8;
                            let high = ((val >> 8) & 0xFF) as u8;
                            self.output.push(format!("  LDA #${:02X}", low));
                            self.output.push(format!("  STA ${:04X}", addr));
                            self.output.push(format!("  LDA #${:02X}", high));
                            self.output.push(format!("  STA ${:04X}", addr + 1));
                        }
                        _ => {
                            let rtype = self.generate_expression(expr)?;
                            self.output.push(format!("  STA ${:04X}", addr));
                            if rtype == DataType::Word {
                                self.output.push(format!("  STX ${:04X}", addr + 1));
                            } else {
                                self.output.push("  LDA #0".to_string());
                                self.output.push(format!("  STA ${:04X}", addr + 1));
                            }
                        }
                    },
                    _ => {
                        self.generate_expression(expr)?;
                        self.output.push(format!("  STA ${:04X}", addr));
                    }
                }
            }
            Statement::Call(target, args) => {
                if let Expression::Identifier(name) = target {
                    let params = if let Some(p) = self.sub_signatures.get(name) {
                        p.clone()
                    } else {
                        return Err(format!("Undefined sub '{}'", name));
                    };
                    if args.len() != params.len() {
                        return Err(format!("Arg mismatch for {}", name));
                    }
                    self.generate_args(&params, args)?;
                    self.output.push(format!("  JSR {}", name));
                } else {
                    return Err("Only direct sub calls are supported in Statement".to_string());
                }
            }
            Statement::If(condition, then_block, else_block) => {
                let else_label = self.new_label();
                let end_label = self.new_label();
                self.generate_expression(condition)?;
                self.output.push("  CMP #0".to_string());
                if else_block.is_some() {
                    self.output.push(format!("  BEQ {}", else_label));
                } else {
                    self.output.push(format!("  BEQ {}", end_label));
                }
                self.generate_block(then_block)?;
                self.output.push(format!("  JMP {}", end_label));
                if let Some(else_stmts) = else_block {
                    self.output.push(format!("{}:", else_label));
                    self.generate_block(else_stmts)?;
                }
                self.output.push(format!("{}:", end_label));
            }
            Statement::While(condition, body) => {
                let start_label = self.new_label();
                let end_label = self.new_label();
                self.output.push(format!("{}:", start_label));
                self.generate_expression(condition)?;
                self.output.push("  CMP #0".to_string());
                self.output.push(format!("  BEQ {}", end_label));
                self.generate_block(body)?;
                self.output.push(format!("  JMP {}", start_label));
                self.output.push(format!("{}:", end_label));
            }
            Statement::DoWhile(body, condition) => {
                let start_label = self.new_label();
                self.output.push(format!("{}:", start_label));
                self.generate_block(body)?;
                self.generate_expression(condition)?;
                self.output.push("  CMP #0".to_string());
                self.output.push(format!("  BNE {}", start_label));
            }
            Statement::For(var_name, start_expr, end_expr, step_expr, body) => {
                let loop_label = self.new_label();
                let exit_label = self.new_label();
                let is_negative_step = match step_expr {
                    Some(Expression::Integer(val)) => *val < 0,
                    _ => false, // Simplification
                };

                self.generate_statement(&Statement::Let(
                    Expression::Identifier(var_name.clone()),
                    start_expr.clone(),
                ))?;
                self.output.push(format!("{}:", loop_label));

                self.generate_expression(&Expression::Identifier(var_name.clone()))?;
                self.output.push("  PHA".to_string());
                self.generate_expression(end_expr)?;
                self.output.push("  STA $00".to_string());
                self.output.push("  PLA".to_string());
                self.output.push("  CMP $00".to_string());

                let body_label = self.new_label();
                if is_negative_step {
                    self.output.push(format!("  BCC {}", exit_label));
                } else {
                    self.output.push(format!("  BEQ {}", body_label));
                    self.output.push(format!("  BCC {}", body_label));
                    self.output.push(format!("  JMP {}", exit_label));
                }
                self.output.push(format!("{}:", body_label));

                self.generate_block(body)?;

                self.generate_expression(&Expression::Identifier(var_name.clone()))?;
                self.output.push("  PHA".to_string());
                if let Some(step) = step_expr {
                    self.generate_expression(step)?;
                } else {
                    self.output.push("  LDA #1".to_string());
                }
                self.output.push("  STA $00".to_string());
                self.output.push("  PLA".to_string());
                self.output.push("  CLC".to_string());
                self.output.push("  ADC $00".to_string());
                if let Some(sym) = self.symbol_table.resolve(var_name) {
                    if let Some(addr) = sym.address {
                        self.output.push(format!("  STA ${:04X}", addr));
                    }
                }
                if is_negative_step {
                    self.output.push(format!("  BCC {}", exit_label));
                }
                self.output.push(format!("  JMP {}", loop_label));
                self.output.push(format!("{}:", exit_label));
            }
            Statement::Return(expr) => {
                if let Some(e) = expr {
                    self.generate_expression(e)?;
                }
                self.output.push("  RTS".to_string());
            }
            Statement::Asm(lines) => {
                for line in lines {
                    self.output.push(format!("  {}", line));
                }
            }
            Statement::Poke(addr_expr, val_expr) => {
                self.generate_expression(val_expr)?;
                self.output.push("  PHA".to_string());

                // Optimization: Check for constant address
                let const_addr = match addr_expr {
                    Expression::Integer(val) => Some(*val as u16),
                    Expression::Identifier(name) => self
                        .symbol_table
                        .resolve(name)
                        .and_then(|sym| sym.value.map(|val| val as u16)),
                    _ => None,
                };

                if let Some(addr) = const_addr {
                    self.output.push("  PLA".to_string());
                    self.output.push(format!("  STA ${:04X}", addr));
                } else {
                    self.generate_address_expression(addr_expr)?;
                    self.output.push("  LDY #$00".to_string());
                    self.output.push("  PLA".to_string());
                    self.output.push("  STA ($02),y".to_string());
                }
            }
            Statement::PlaySfx(id_expr) => {
                self.generate_expression(id_expr)?;
                self.output.push("  JSR Sound_Play".to_string());
            }
            Statement::Read(vars) => {
                for name in vars {
                    if let Some(sym) = self.symbol_table.resolve(name) {
                        if let Some(addr) = sym.address {
                            match sym.data_type {
                                DataType::Byte | DataType::Bool | DataType::Int => {
                                    self.output.push("  JSR Runtime_ReadByte".to_string());
                                    self.output.push(format!("  STA ${:04X}", addr));
                                }
                                DataType::Word => {
                                    self.output.push("  JSR Runtime_ReadByte".to_string());
                                    self.output.push(format!("  STA ${:04X}", addr));
                                    self.output.push("  JSR Runtime_ReadByte".to_string());
                                    self.output.push(format!("  STA ${:04X}", addr + 1));
                                }
                                DataType::String => {
                                    self.output.push("  JSR Runtime_ReadString".to_string());
                                    self.output.push(format!("  STA ${:04X}", addr));
                                    self.output.push(format!("  STX ${:04X}", addr + 1));
                                }
                                _ => {
                                    // Structs/Arrays not supported in READ
                                }
                            }
                        }
                    }
                }
            }
            Statement::Restore(label) => {
                let target = label.as_deref().unwrap_or("USER_DATA_START");
                if let Some(addr) = self.data_table_offsets.get(target) {
                    self.output.push(format!("  LDA ${:04X}", addr));
                    self.output.push("  STA $04".to_string());
                    self.output.push(format!("  LDA ${:04X}", addr + 1));
                    self.output.push("  STA $05".to_string());
                }
            }
            Statement::Select(expr, cases, case_else) => {
                let end_select_label = self.new_label();

                // 1. Evaluate Expression
                let expr_type = self.generate_expression(expr)?;

                // 2. Push to Stack
                match expr_type {
                    DataType::Byte | DataType::Bool | DataType::Int => {
                        self.output.push("  PHA".to_string());
                    }
                    DataType::Word | DataType::String => {
                        self.output.push("  PHA".to_string()); // Low
                        self.output.push("  TXA".to_string());
                        self.output.push("  PHA".to_string()); // High
                    }
                    DataType::Struct(_) | DataType::Array(_, _) => {
                        return Err("Cannot SELECT on struct/array".to_string());
                    }
                }

                // 3. Generate Checks
                for (case_val, case_body) in cases {
                    let next_case = self.new_label();

                    // Eval Case Value -> A/X
                    self.generate_expression(case_val)?;

                    // Compare (Stack vs A/X)
                    self.output.push("  TSX".to_string());

                    match expr_type {
                        DataType::Byte | DataType::Bool | DataType::Int => {
                            // A has Case Val. Stack has Select Val at $0101,X
                            self.output.push("  CMP $0101, X".to_string());
                            self.output.push(format!("  BNE {}", next_case));
                        }
                        _ => {
                            // A=Low, X=High of Case Val.
                            // Stack: High at 101, Low at 102.
                            // We must save X (High Byte) because TSX clobbers it.
                            self.output.push("  STX $01".to_string()); // Save High
                            self.output.push("  TSX".to_string());

                            self.output.push("  CMP $0102, X".to_string()); // Compare Low
                            self.output.push(format!("  BNE {}", next_case));

                            self.output.push("  LDA $01".to_string()); // Restore High
                            self.output.push("  CMP $0101, X".to_string()); // Compare High
                            self.output.push(format!("  BNE {}", next_case));
                        }
                    }

                    // If we are here, it matched.
                    self.generate_block(case_body)?;
                    self.output.push(format!("  JMP {}", end_select_label));

                    self.output.push(format!("{}:", next_case));
                }

                // Else
                if let Some(else_body) = case_else {
                    self.generate_block(else_body)?;
                }

                self.output.push(format!("{}:", end_select_label));

                // 4. Pop Stack
                match expr_type {
                    DataType::Byte | DataType::Bool | DataType::Int => {
                        self.output.push("  PLA".to_string());
                    }
                    _ => {
                        self.output.push("  PLA".to_string());
                        self.output.push("  PLA".to_string());
                    }
                }
            }
            _ => {}
        }
        Ok(())
    }

    fn generate_args(
        &mut self,
        params: &[(u16, DataType)],
        args: &[Expression],
    ) -> Result<(), String> {
        for (i, expr) in args.iter().enumerate() {
            let (addr, dtype) = params[i].clone();
            match dtype {
                DataType::Word | DataType::String => {
                    let rtype = self.generate_expression(expr)?;
                    self.output.push(format!("  STA ${:04X}", addr));
                    if rtype == DataType::Word {
                        self.output.push(format!("  STX ${:04X}", addr + 1));
                    } else {
                        self.output.push("  LDA #0".to_string());
                        self.output.push(format!("  STA ${:04X}", addr + 1));
                    }
                }
                _ => {
                    self.generate_expression(expr)?;
                    self.output.push(format!("  STA ${:04X}", addr));
                }
            }
        }
        Ok(())
    }

    fn get_static_address(&self, expr: &Expression) -> Result<u16, String> {
        match expr {
            Expression::Identifier(name) => self
                .symbol_table
                .resolve(name)
                .and_then(|s| s.address)
                .ok_or_else(|| format!("Symbol '{}' has no address", name)),
            Expression::MemberAccess(base, member) => {
                let base_addr = self.get_static_address(base)?;
                let base_type = self.resolve_type(base).ok_or("Unknown base type")?;
                if let DataType::Struct(s_name) = base_type {
                    if let Some(sym) = self.symbol_table.resolve(&s_name) {
                        if let Some(members) = &sym.members {
                            for (m_name, _, offset) in members {
                                if m_name == member {
                                    return Ok(base_addr + offset);
                                }
                            }
                        }
                    }
                }
                Err("Member error".to_string())
            }
            _ => Err("Not static".to_string()),
        }
    }

    fn resolve_type(&self, expr: &Expression) -> Option<DataType> {
        match expr {
            Expression::Identifier(name) => {
                self.symbol_table.resolve(name).map(|s| s.data_type.clone())
            }
            Expression::MemberAccess(base, member) => {
                let base_type = self.resolve_type(base)?;
                if let DataType::Struct(struct_name) = base_type {
                    if let Some(sym) = self.symbol_table.resolve(&struct_name) {
                        if let Some(members) = &sym.members {
                            for (m, t, _) in members {
                                if m == member {
                                    return Some(t.clone());
                                }
                            }
                        }
                    }
                }
                None
            }
            Expression::Call(callee, _) => {
                // If array, return inner type
                if let Some(DataType::Array(inner, _)) = self.resolve_type(callee) {
                    return Some(*inner);
                }
                Some(DataType::Word) // Default for Function call
            }
            Expression::Integer(_) => Some(DataType::Word),
            Expression::BinaryOp(_, _, _) => Some(DataType::Word),
            Expression::UnaryOp(_, _) => Some(DataType::Int),
            _ => Some(DataType::Byte),
        }
    }

    // Generates address in $02/$03
    fn generate_array_address(
        &mut self,
        callee: &Expression,
        index_expr: &Expression,
    ) -> Result<(), String> {
        // 1. Get Base Address
        let base_addr = self.get_static_address(callee)?;

        // 2. Evaluate Index -> A (Byte) or A/X (Word)
        // We will promote Byte to Word ($00/$01)
        let idx_type = self.generate_expression(index_expr)?;

        self.output.push("  STA $00".to_string());
        if idx_type == DataType::Word || idx_type == DataType::Int {
            self.output.push("  STX $01".to_string());
        } else {
            self.output.push("  LDA #0".to_string());
            self.output.push("  STA $01".to_string());
        }

        // 3. Get Element Size
        let elem_size = if let Some(DataType::Array(inner, _)) = self.resolve_type(callee) {
            self.get_type_size(&inner)
        } else {
            1
        };

        // 4. Multiply Index * Size
        if elem_size > 1 {
            self.output.push("  LDA $00".to_string()); // Low
            self.output.push("  LDX $01".to_string()); // High
            self.output.push(format!("  LDY #{}", elem_size)); // Size (Assuming small size, < 256)
                                                               // Math_Mul16 uses A/X * $00/$01.
                                                               // We need X * Y?
                                                               // We don't have Mul16(A, Y).
                                                               // Helper Mul16 expects $00/$01.
                                                               // Save size to $00/$01? No, Index is there.
                                                               // Move Index to A/X.
                                                               // Move Size to $00/$01.
            self.output.push("  PHA".to_string()); // Index Low
            self.output.push("  TXA".to_string());
            self.output.push("  PHA".to_string()); // Index High

            self.output.push(format!("  LDA #{}", elem_size));
            self.output.push("  STA $00".to_string());
            self.output.push("  LDA #0".to_string());
            self.output.push("  STA $01".to_string());

            self.output.push("  PLA".to_string()); // High
            self.output.push("  TAX".to_string());
            self.output.push("  PLA".to_string()); // Low

            self.output.push("  JSR Math_Mul16".to_string());
            // Result in A/X
            self.output.push("  STA $00".to_string());
            self.output.push("  STX $01".to_string());
        }

        // 5. Add Base Address
        self.output.push("  LDA $00".to_string());
        self.output.push("  CLC".to_string());
        self.output
            .push(format!("  ADC #${:02X}", (base_addr & 0xFF) as u8));
        self.output.push("  STA $02".to_string());

        self.output.push("  LDA $01".to_string());
        self.output
            .push(format!("  ADC #${:02X}", ((base_addr >> 8) & 0xFF) as u8));
        self.output.push("  STA $03".to_string());

        Ok(())
    }

    fn generate_address_expression(&mut self, expr: &Expression) -> Result<(), String> {
        match expr {
            Expression::Call(callee, args) => {
                self.generate_array_address(callee, &args[0])?;
            }
            Expression::Integer(val) => {
                let low = (val & 0xFF) as u8;
                let high = ((val >> 8) & 0xFF) as u8;
                self.output.push(format!("  LDA #${:02X}", low));
                self.output.push("  STA $02".to_string());
                self.output.push(format!("  LDA #${:02X}", high));
                self.output.push("  STA $03".to_string());
            }
            Expression::Identifier(name) => {
                if let Some(sym) = self.symbol_table.resolve(name) {
                    if let Some(addr) = sym.address {
                        match sym.data_type {
                            DataType::Word | DataType::String => {
                                self.output.push(format!("  LDA ${:04X}", addr));
                                self.output.push("  STA $02".to_string());
                                self.output.push(format!("  LDA ${:04X}", addr + 1));
                                self.output.push("  STA $03".to_string());
                            }
                            _ => {
                                self.output.push(format!("  LDA ${:04X}", addr));
                                self.output.push("  STA $02".to_string());
                                self.output.push("  LDA #0".to_string());
                                self.output.push("  STA $03".to_string());
                            }
                        }
                    } else if sym.kind == SymbolKind::Constant {
                        if let Some(val) = sym.value {
                            let low = (val & 0xFF) as u8;
                            let high = ((val >> 8) & 0xFF) as u8;
                            self.output.push(format!("  LDA #${:02X}", low));
                            self.output.push("  STA $02".to_string());
                            self.output.push(format!("  LDA #${:02X}", high));
                            self.output.push("  STA $03".to_string());
                        } else {
                            return Err(format!("Constant '{}' has no value", name));
                        }
                    } else {
                        return Err(format!("Symbol '{}' has no address", name));
                    }
                } else {
                    return Err(format!("Undefined symbol '{}'", name));
                }
            }
            _ => {
                let addr = self.get_static_address(expr)?;
                let low = (addr & 0xFF) as u8;
                let high = ((addr >> 8) & 0xFF) as u8;
                self.output.push(format!("  LDA #${:02X}", low));
                self.output.push("  STA $02".to_string());
                self.output.push(format!("  LDA #${:02X}", high));
                self.output.push("  STA $03".to_string());
            }
        }
        Ok(())
    }

    fn generate_expression(&mut self, expr: &Expression) -> Result<DataType, String> {
        match expr {
            Expression::Call(callee, args) => {
                // Determine if Array or Sub
                if let Some(DataType::Array(_, _)) = self.resolve_type(callee) {
                    // Array Access
                    // 1. Calc Address in $02/$03
                    self.generate_array_address(callee, &args[0])?;

                    let rtype = self.resolve_type(expr).unwrap();
                    self.output.push("  LDY #0".to_string());
                    match rtype {
                        DataType::Byte | DataType::Bool | DataType::Int => {
                            self.output.push("  LDA ($02),Y".to_string());
                            self.output.push("  LDX #0".to_string());
                        }
                        DataType::Word | DataType::String => {
                            self.output.push("  LDA ($02),Y".to_string());
                            self.output.push("  PHA".to_string()); // Low
                            self.output.push("  INY".to_string());
                            self.output.push("  LDA ($02),Y".to_string());
                            self.output.push("  TAX".to_string());
                            self.output.push("  PLA".to_string());
                        }
                        _ => {}
                    }
                    Ok(rtype)
                } else {
                    // Function Call
                    if let Expression::Identifier(name) = &**callee {
                        let params = if let Some(p) = self.sub_signatures.get(name) {
                            p.clone()
                        } else {
                            return Err(format!("Undefined function '{}'", name));
                        };
                        if args.len() != params.len() {
                            return Err("Arg mismatch".to_string());
                        }
                        self.generate_args(&params, args)?;
                        self.output.push(format!("  JSR {}", name));
                        Ok(DataType::Word)
                    } else {
                        Err("Indirect function call not supported".to_string())
                    }
                }
            }
            Expression::Integer(val) => {
                let low = (val & 0xFF) as u8;
                let high = ((val >> 8) & 0xFF) as u8;
                self.output.push(format!("  LDA #${:02X}", low));
                self.output.push(format!("  LDX #${:02X}", high));
                Ok(DataType::Word)
            }
            Expression::StringLiteral(s) => {
                if let Some(label) = self.string_literals.get(s) {
                    if let Some(addr) = self.data_table_offsets.get(label) {
                        self.output.push(format!("  LDA ${:04X}", addr));
                        self.output.push(format!("  LDX ${:04X}", addr + 1));
                        Ok(DataType::String)
                    } else {
                        Err("No table entry".to_string())
                    }
                } else {
                    Err("String not alloc".to_string())
                }
            }
            Expression::Identifier(name) => {
                if let Some(sym) = self.symbol_table.resolve(name) {
                    if let Some(addr) = sym.address {
                        match sym.data_type {
                            DataType::Word | DataType::String => {
                                self.output.push(format!("  LDA ${:04X}", addr));
                                self.output.push(format!("  LDX ${:04X}", addr + 1));
                                Ok(sym.data_type.clone())
                            }
                            DataType::Int => {
                                self.output.push(format!("  LDA ${:04X}", addr));
                                self.output.push("  CMP #$80".to_string());
                                let pos_lbl = self.new_label();
                                let done_lbl = self.new_label();
                                self.output.push(format!("  BCC {}", pos_lbl));
                                self.output.push("  LDX #$FF".to_string());
                                self.output.push(format!("  JMP {}", done_lbl));
                                self.output.push(format!("{}:", pos_lbl));
                                self.output.push("  LDX #0".to_string());
                                self.output.push(format!("{}:", done_lbl));
                                Ok(DataType::Int)
                            }
                            _ => {
                                self.output.push(format!("  LDA ${:04X}", addr));
                                self.output.push("  LDX #0".to_string());
                                Ok(DataType::Byte)
                            }
                        }
                    } else if sym.kind == SymbolKind::Constant {
                        if let Some(val) = sym.value {
                            let low = (val & 0xFF) as u8;
                            let high = ((val >> 8) & 0xFF) as u8;
                            self.output.push(format!("  LDA #${:02X}", low));
                            self.output.push(format!("  LDX #${:02X}", high));
                            Ok(DataType::Word)
                        } else {
                            Err("Const no val".to_string())
                        }
                    } else {
                        Err("No addr".to_string())
                    }
                } else {
                    Err("Undefined".to_string())
                }
            }
            Expression::BinaryOp(l, op, r) => {
                let tl = self.generate_expression(l)?;
                if tl == DataType::Byte || tl == DataType::Bool {
                    self.output.push("  PHA".to_string());
                } else {
                    self.output.push("  PHA".to_string());
                    self.output.push("  TXA".to_string());
                    self.output.push("  PHA".to_string());
                }
                let tr = self.generate_expression(r)?;

                let is_16 = tl == DataType::Word
                    || tr == DataType::Word
                    || tl == DataType::Int
                    || tr == DataType::Int;
                let is_signed = tl == DataType::Int || tr == DataType::Int;

                if is_16 {
                    if tr == DataType::Byte || tr == DataType::Bool {
                        self.output.push("  STA $00".to_string());
                        self.output.push("  LDA #0".to_string());
                        self.output.push("  STA $01".to_string());
                    } else {
                        self.output.push("  STA $00".to_string());
                        self.output.push("  STX $01".to_string());
                    }

                    if tl == DataType::Byte || tl == DataType::Bool {
                        self.output.push("  PLA".to_string());
                        self.output.push("  LDX #0".to_string());
                    } else {
                        self.output.push("  PLA".to_string());
                        self.output.push("  TAX".to_string());
                        self.output.push("  PLA".to_string());
                    }

                    match op {
                        BinaryOperator::Add => {
                            self.output.push("  CLC".to_string());
                            self.output.push("  ADC $00".to_string());
                            self.output.push("  PHA".to_string());
                            self.output.push("  TXA".to_string());
                            self.output.push("  ADC $01".to_string());
                            self.output.push("  TAX".to_string());
                            self.output.push("  PLA".to_string());
                            if is_signed {
                                Ok(DataType::Int)
                            } else {
                                Ok(DataType::Word)
                            }
                        }
                        BinaryOperator::Subtract => {
                            self.output.push("  SEC".to_string());
                            self.output.push("  SBC $00".to_string());
                            self.output.push("  PHA".to_string());
                            self.output.push("  TXA".to_string());
                            self.output.push("  SBC $01".to_string());
                            self.output.push("  TAX".to_string());
                            self.output.push("  PLA".to_string());
                            if is_signed {
                                Ok(DataType::Int)
                            } else {
                                Ok(DataType::Word)
                            }
                        }
                        BinaryOperator::Multiply => {
                            self.output.push("  JSR Math_Mul16".to_string());
                            if is_signed {
                                Ok(DataType::Int)
                            } else {
                                Ok(DataType::Word)
                            }
                        }
                        BinaryOperator::Divide => {
                            if is_signed {
                                self.output.push("  JSR Math_Div16_Signed".to_string());
                                Ok(DataType::Int)
                            } else {
                                self.output.push("  JSR Math_Div16".to_string());
                                Ok(DataType::Word)
                            }
                        }
                        BinaryOperator::Modulo => {
                            if is_signed {
                                self.output.push("  JSR Math_Div16_Signed".to_string());
                                self.output.push("  LDA $08".to_string());
                                self.output.push("  LDX $09".to_string());
                                Ok(DataType::Int)
                            } else {
                                self.output.push("  JSR Math_Div16".to_string());
                                self.output.push("  LDA $08".to_string());
                                self.output.push("  LDX $09".to_string());
                                Ok(DataType::Word)
                            }
                        }
                        BinaryOperator::And => {
                            self.output.push("  AND $00".to_string());
                            self.output.push("  PHA".to_string());
                            self.output.push("  TXA".to_string());
                            self.output.push("  AND $01".to_string());
                            self.output.push("  TAX".to_string());
                            self.output.push("  PLA".to_string());
                            if is_signed {
                                Ok(DataType::Int)
                            } else {
                                Ok(DataType::Word)
                            }
                        }
                        BinaryOperator::Or => {
                            self.output.push("  ORA $00".to_string());
                            self.output.push("  PHA".to_string());
                            self.output.push("  TXA".to_string());
                            self.output.push("  ORA $01".to_string());
                            self.output.push("  TAX".to_string());
                            self.output.push("  PLA".to_string());
                            if is_signed {
                                Ok(DataType::Int)
                            } else {
                                Ok(DataType::Word)
                            }
                        }
                        _ => {
                            let true_lbl = self.new_label();
                            let false_lbl = self.new_label();
                            let end_lbl = self.new_label();

                            match op {
                                BinaryOperator::Equal | BinaryOperator::NotEqual => {
                                    self.output.push("  CPX $01".to_string());
                                    self.output.push(format!("  BNE {}", false_lbl));
                                    self.output.push("  CMP $00".to_string());
                                    if matches!(op, BinaryOperator::Equal) {
                                        self.output.push(format!("  BNE {}", false_lbl));
                                    } else {
                                        self.output.push(format!("  BEQ {}", false_lbl));
                                    }
                                    self.output.push(format!("  JMP {}", true_lbl));
                                }
                                BinaryOperator::LessThan
                                | BinaryOperator::GreaterThan
                                | BinaryOperator::LessThanOrEqual
                                | BinaryOperator::GreaterThanOrEqual => {
                                    self.output.push("  SEC".to_string());
                                    self.output.push("  SBC $00".to_string());
                                    self.output.push("  PHA".to_string());
                                    self.output.push("  TXA".to_string());
                                    self.output.push("  SBC $01".to_string());
                                    self.output.push("  TAX".to_string());
                                    self.output.push("  PLA".to_string());

                                    if is_signed {
                                        let overflow_lbl = self.new_label();
                                        match op {
                                            BinaryOperator::LessThan => {
                                                self.output.push(format!("  BVS {}", overflow_lbl));
                                                self.output.push(format!("  BMI {}", true_lbl));
                                                self.output.push(format!("  JMP {}", false_lbl));
                                                self.output.push(format!("{}:", overflow_lbl));
                                                self.output.push(format!("  BPL {}", true_lbl));
                                                self.output.push(format!("  JMP {}", false_lbl));
                                            }
                                            BinaryOperator::GreaterThanOrEqual => {
                                                self.output.push(format!("  BVS {}", overflow_lbl));
                                                self.output.push(format!("  BPL {}", true_lbl));
                                                self.output.push(format!("  JMP {}", false_lbl));
                                                self.output.push(format!("{}:", overflow_lbl));
                                                self.output.push(format!("  BMI {}", true_lbl));
                                                self.output.push(format!("  JMP {}", false_lbl));
                                            }
                                            BinaryOperator::GreaterThan => {
                                                self.output.push(format!("  BVS {}", overflow_lbl));
                                                self.output.push(format!("  BMI {}", false_lbl));
                                                self.output.push("  STX $01".to_string());
                                                self.output.push("  ORA $01".to_string());
                                                self.output.push(format!("  BEQ {}", false_lbl));
                                                self.output.push(format!("  JMP {}", true_lbl));

                                                self.output.push(format!("{}:", overflow_lbl));
                                                self.output.push(format!("  BPL {}", false_lbl));
                                                self.output.push(format!("  JMP {}", true_lbl));
                                            }
                                            BinaryOperator::LessThanOrEqual => {
                                                self.output.push(format!("  BVS {}", overflow_lbl));
                                                self.output.push(format!("  BMI {}", true_lbl));
                                                self.output.push("  STX $01".to_string());
                                                self.output.push("  ORA $01".to_string());
                                                self.output.push(format!("  BEQ {}", true_lbl));
                                                self.output.push(format!("  JMP {}", false_lbl));

                                                self.output.push(format!("{}:", overflow_lbl));
                                                self.output.push(format!("  BPL {}", true_lbl));
                                                self.output.push(format!("  JMP {}", false_lbl));
                                            }
                                            _ => {}
                                        }
                                    } else {
                                        match op {
                                            BinaryOperator::LessThan => {
                                                self.output.push(format!("  BCC {}", true_lbl));
                                                self.output.push(format!("  JMP {}", false_lbl));
                                            }
                                            BinaryOperator::GreaterThanOrEqual => {
                                                self.output.push(format!("  BCS {}", true_lbl));
                                                self.output.push(format!("  JMP {}", false_lbl));
                                            }
                                            BinaryOperator::GreaterThan => {
                                                self.output.push(format!("  BCC {}", false_lbl));
                                                self.output.push("  STX $01".to_string());
                                                self.output.push("  ORA $01".to_string());
                                                self.output.push(format!("  BNE {}", true_lbl));
                                                self.output.push(format!("  JMP {}", false_lbl));
                                            }
                                            BinaryOperator::LessThanOrEqual => {
                                                self.output.push(format!("  BCC {}", true_lbl));
                                                self.output.push("  STX $01".to_string());
                                                self.output.push("  ORA $01".to_string());
                                                self.output.push(format!("  BEQ {}", true_lbl));
                                                self.output.push(format!("  JMP {}", false_lbl));
                                            }
                                            _ => {}
                                        }
                                    }
                                }
                                _ => {}
                            }
                            self.output.push(format!("{}:", false_lbl));
                            self.output.push("  LDA #0".to_string());
                            self.output.push(format!("  JMP {}", end_lbl));
                            self.output.push(format!("{}:", true_lbl));
                            self.output.push("  LDA #1".to_string());
                            self.output.push(format!("{}:", end_lbl));
                            self.output.push("  LDX #0".to_string());
                            Ok(DataType::Bool)
                        }
                    }
                } else {
                    self.output.push("  STA $00".to_string());
                    self.output.push("  PLA".to_string());
                    match op {
                        BinaryOperator::Add => {
                            self.output.push("  CLC".to_string());
                            self.output.push("  ADC $00".to_string());
                        }
                        BinaryOperator::Subtract => {
                            self.output.push("  SEC".to_string());
                            self.output.push("  SBC $00".to_string());
                        }
                        BinaryOperator::Multiply => {
                            self.output.push("  JSR Math_Mul8".to_string());
                        }
                        _ => {}
                    }
                    self.output.push("  LDX #0".to_string());
                    Ok(DataType::Byte)
                }
            }
            Expression::MemberAccess(_base, _member) => {
                let addr = self.get_static_address(expr)?;
                let dtype = self.resolve_type(expr).unwrap();
                match dtype {
                    DataType::Word => {
                        self.output.push(format!("  LDA ${:04X}", addr));
                        self.output.push(format!("  LDX ${:04X}", addr + 1));
                    }
                    DataType::Int => {
                        self.output.push(format!("  LDA ${:04X}", addr));
                        self.output.push("  CMP #$80".to_string());
                        let pos_lbl = self.new_label();
                        let done_lbl = self.new_label();
                        self.output.push(format!("  BCC {}", pos_lbl));
                        self.output.push("  LDX #$FF".to_string());
                        self.output.push(format!("  JMP {}", done_lbl));
                        self.output.push(format!("{}:", pos_lbl));
                        self.output.push("  LDX #0".to_string());
                        self.output.push(format!("{}:", done_lbl));
                    }
                    _ => {
                        self.output.push(format!("  LDA ${:04X}", addr));
                        self.output.push("  LDX #0".to_string());
                    }
                }
                Ok(dtype)
            }
            _ => Ok(DataType::Byte),
        }
    }
}
