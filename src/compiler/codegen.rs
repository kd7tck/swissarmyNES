use crate::compiler::ast::{
    BinaryOperator, DataType, Expression, Program, Statement, TopLevel, UnaryOperator,
};
use crate::compiler::symbol_table::{SymbolKind, SymbolTable};
use std::collections::HashMap;

pub const NAMETABLE_ADDR: u16 = 0xD500;

pub struct CodeGenerator {
    symbol_table: SymbolTable, // We might need to clone or move the symbol table from Analyzer
    output: Vec<String>,
    ram_pointer: u16,
    label_counter: usize,
    data_table_offsets: HashMap<String, u16>,
    sub_signatures: HashMap<String, Vec<(u16, DataType)>>,
}

impl CodeGenerator {
    pub fn new(symbol_table: SymbolTable) -> Self {
        Self {
            symbol_table,
            output: Vec::new(),
            ram_pointer: 0x0000, // Zero Page start (or wherever we want to start)
            label_counter: 0,
            data_table_offsets: HashMap::new(),
            sub_signatures: HashMap::new(),
        }
    }

    fn new_label(&mut self) -> String {
        self.label_counter += 1;
        format!("GEN_L{}", self.label_counter)
    }

    pub fn generate(&mut self, program: &Program) -> Result<Vec<String>, String> {
        self.output.clear();
        self.output.push(".ORG $8000".to_string()); // Start of PRG ROM
        self.output.push("; Generated by SwissArmyNES".to_string());

        // Standard NES System Vectors (to be placed at $FFFA)
        // NMI, RESET, IRQ
        // We will generate a "Reset" routine that initializes the system and calls Main
        // NMI and IRQ will point to user defined handlers or RTI

        // Pass 1: Allocate variables
        self.allocate_memory(program)?;

        // Pass 2: Generate code
        self.generate_startup_routine(program)?;

        for decl in &program.declarations {
            self.generate_top_level(decl)?;
        }

        // Pass 3: Generate Sound Engine Code
        self.generate_sound_engine();
        self.generate_math_helpers();

        // Pass 4: Generate Data Tables (at $FF00)
        self.generate_data_tables(program)?;

        // Pass 5: Generate Vectors
        self.generate_vectors(program)?;

        Ok(self.output.clone())
    }

    fn generate_startup_routine(&mut self, program: &Program) -> Result<(), String> {
        self.output.push("Startup:".to_string());
        self.output
            .push("  SEI          ; Disable IRQs".to_string());
        self.output
            .push("  CLD          ; Disable Decimal Mode".to_string());
        self.output.push("  LDX #$40".to_string());
        self.output
            .push("  STX $4017    ; Disable APU frame IRQ".to_string());
        self.output.push("  LDX #$FF".to_string());
        self.output
            .push("  TXS          ; Set Stack Pointer to $FF".to_string());
        self.output.push("  INX          ; X = 0".to_string());
        self.output.push("  STX $2000    ; Disable NMI".to_string());
        self.output
            .push("  STX $2001    ; Disable Rendering".to_string());
        self.output
            .push("  STX $4010    ; Disable DMC IRQs".to_string());

        // Wait for VBLANK (1)
        self.output.push("vblankwait1:".to_string());
        self.output.push("  BIT $2002".to_string());
        self.output.push("  BPL vblankwait1".to_string());

        // Clear Memory (RAM)
        self.output.push("clrmem:".to_string());
        self.output.push("  LDA #$00".to_string());
        self.output.push("  STA $00,x".to_string());
        self.output.push("  STA $0100,x".to_string());
        self.output.push("  STA $0300,x".to_string());
        self.output.push("  STA $0400,x".to_string());
        self.output.push("  STA $0500,x".to_string());
        self.output.push("  STA $0600,x".to_string());
        self.output.push("  STA $0700,x".to_string());
        self.output.push("  LDA #$FE".to_string());
        self.output
            .push("  STA $0200,x ; Move sprites offscreen".to_string());
        self.output.push("  INX".to_string());
        self.output.push("  BNE clrmem".to_string());

        // Wait for VBLANK (2)
        self.output.push("vblankwait2:".to_string());
        self.output.push("  BIT $2002".to_string());
        self.output.push("  BPL vblankwait2".to_string());

        // --- Load Palette ---
        // We load from $E000 where the assembler injected the palette data.
        self.output.push("  ; Load Palettes".to_string());
        self.output.push("  LDA #$3F".to_string());
        self.output.push("  STA $2006".to_string());
        self.output.push("  LDA #$00".to_string());
        self.output.push("  STA $2006".to_string());

        self.output.push("  LDX #$00".to_string());
        self.output.push("LoadPalLoop:".to_string());
        self.output.push("  LDA $E000, X".to_string());
        self.output.push("  STA $2007".to_string());
        self.output.push("  INX".to_string());
        self.output.push("  CPX #32".to_string());
        self.output.push("  BNE LoadPalLoop".to_string());

        // --- Load Nametable ---
        // Load from NAMETABLE_ADDR ($D500)
        self.output.push("  ; Load Nametable".to_string());
        self.output.push("  LDA #$20".to_string());
        self.output.push("  STA $2006".to_string());
        self.output.push("  LDA #$00".to_string());
        self.output.push("  STA $2006".to_string());

        // Loop 1 (0-255)
        self.output.push("  LDX #$00".to_string());
        self.output.push("LoadNT1:".to_string());
        self.output
            .push(format!("  LDA ${:04X}, X", NAMETABLE_ADDR));
        self.output.push("  STA $2007".to_string());
        self.output.push("  INX".to_string());
        self.output.push("  BNE LoadNT1".to_string());

        // Loop 2 (256-511)
        self.output.push("  LDX #$00".to_string());
        self.output.push("LoadNT2:".to_string());
        self.output
            .push(format!("  LDA ${:04X}, X", NAMETABLE_ADDR + 256));
        self.output.push("  STA $2007".to_string());
        self.output.push("  INX".to_string());
        self.output.push("  BNE LoadNT2".to_string());

        // Loop 3 (512-767)
        self.output.push("  LDX #$00".to_string());
        self.output.push("LoadNT3:".to_string());
        self.output
            .push(format!("  LDA ${:04X}, X", NAMETABLE_ADDR + 512));
        self.output.push("  STA $2007".to_string());
        self.output.push("  INX".to_string());
        self.output.push("  BNE LoadNT3".to_string());

        // Loop 4 (768-1023)
        self.output.push("  LDX #$00".to_string());
        self.output.push("LoadNT4:".to_string());
        self.output
            .push(format!("  LDA ${:04X}, X", NAMETABLE_ADDR + 768));
        self.output.push("  STA $2007".to_string());
        self.output.push("  INX".to_string());
        self.output.push("  BNE LoadNT4".to_string());

        // Initialize Sound Engine
        self.output.push("  JSR Sound_Init".to_string());

        // Initialize Interrupt Vectors in RAM
        // NMI @ $03FA, IRQ @ $03FC
        // Default to RTI (which we will define as a label DefaultRTI)

        // Generate DefaultRTI
        // We will output it later in the stream or just jump to an RTS if we want, but RTI is needed.
        // Let's generate a DefaultRTI label at the end of Startup or elsewhere.
        // Actually, we can just put it here.
        // But we need to initialize RAM.

        // Find NMI Handler in program
        let nmi_label = program.declarations.iter().find_map(|d| {
            if let TopLevel::Interrupt(name, _) = d {
                if name.to_uppercase() == "NMI" {
                    return Some(name.clone());
                }
            }
            None
        });

        // Find IRQ Handler
        let irq_label = program.declarations.iter().find_map(|d| {
            if let TopLevel::Interrupt(name, _) = d {
                if name.to_uppercase() == "IRQ" {
                    return Some(name.clone());
                }
            }
            None
        });

        // We need to mirror the logic in generate_data_tables to find addresses.
        // Start address: $FF00
        let mut current_addr = 0xFF00;

        let addr_default_rti = current_addr;
        current_addr += 2;

        // Helper map to store addresses of Init variables
        let mut init_nmi_addr: Option<u16> = None;
        let mut init_irq_addr: Option<u16> = None;

        // We must iterate in the exact same order as generate_data_tables
        for decl in &program.declarations {
            if let TopLevel::Interrupt(name, _) = decl {
                let upper = name.to_uppercase();
                if upper == "NMI" {
                    init_nmi_addr = Some(current_addr);
                    current_addr += 2;
                } else if upper == "IRQ" {
                    init_irq_addr = Some(current_addr);
                    current_addr += 2;
                }
                current_addr += 2; // Ptr_{}
            }
            if let TopLevel::Sub(_, _, _) = decl {
                current_addr += 2; // Ptr_{}
            }
        }

        // Initialize NMI Vector ($03FA)
        if nmi_label.is_some() {
            if let Some(addr) = init_nmi_addr {
                self.output.push(format!("  LDA ${:04X}", addr));
                self.output.push("  STA $03FA".to_string());
                self.output.push(format!("  LDA ${:04X}", addr + 1));
                self.output.push("  STA $03FB".to_string());
            }
        } else {
            // Default RTI
            self.output.push(format!("  LDA ${:04X}", addr_default_rti));
            self.output.push("  STA $03FA".to_string());
            self.output
                .push(format!("  LDA ${:04X}", addr_default_rti + 1));
            self.output.push("  STA $03FB".to_string());
        }

        // Initialize IRQ Vector ($03FC)
        if irq_label.is_some() {
            if let Some(addr) = init_irq_addr {
                self.output.push(format!("  LDA ${:04X}", addr));
                self.output.push("  STA $03FC".to_string());
                self.output.push(format!("  LDA ${:04X}", addr + 1));
                self.output.push("  STA $03FD".to_string());
            }
        } else {
            self.output.push(format!("  LDA ${:04X}", addr_default_rti));
            self.output.push("  STA $03FC".to_string());
            self.output
                .push(format!("  LDA ${:04X}", addr_default_rti + 1));
            self.output.push("  STA $03FD".to_string());
        }

        // Infinite loop after Main returns
        self.output.push("forever:".to_string());
        self.output.push("  JMP forever".to_string());
        self.output.push("".to_string());

        self.output.push("DefaultRTI:".to_string());
        self.output.push("  RTI".to_string());
        self.output.push("".to_string());

        // Trampolines
        self.output.push("TrampolineNMI:".to_string());
        self.output.push("  JSR Sound_Update".to_string()); // Ensure sound engine runs
        self.output.push("  JMP ($03FA)".to_string());
        self.output.push("TrampolineIRQ:".to_string());
        self.output.push("  JMP ($03FC)".to_string());
        self.output.push("".to_string());

        Ok(())
    }

    fn generate_sound_engine(&mut self) {
        // --- Sound Engine ---
        // State Variables (RAM $02E0 - $02EF)
        // Channel 0: Pulse 1 ($02E0)
        // Channel 1: Pulse 2 ($02E4)
        // Channel 2: Triangle ($02E8)
        // Per Channel:
        // +0: Active (Bool/Byte)
        // +1: Timer (Byte)
        // +2: Ptr Low
        // +3: Ptr High

        self.output.push("; --- Sound Engine ---".to_string());

        // Sound_Init
        self.output.push("Sound_Init:".to_string());
        self.output.push("  LDA #$0F".to_string());
        self.output
            .push("  STA $4015    ; Enable Square 1, 2, Triangle, Noise".to_string());

        // Clear State ($02E0 - $02EF)
        self.output.push("  LDX #$00".to_string());
        self.output.push("  LDA #$00".to_string());
        self.output.push("SndClear:".to_string());
        self.output.push("  STA $02E0, X".to_string());
        self.output.push("  INX".to_string());
        self.output.push("  CPX #$10".to_string());
        self.output.push("  BNE SndClear".to_string());
        self.output.push("  RTS".to_string());

        // Sound_Play
        // Input: A = Track ID
        // Uses $F0-$F1 as scratch for pointer lookup to avoid clobbering $00-$01 used by main code
        self.output.push("Sound_Play:".to_string());
        self.output.push("  PHA          ; Save ID".to_string());

        // Check if ID is valid (Count at $D100)
        self.output.push("  LDA $D100    ; Get Count".to_string());
        self.output.push("  STA $F0".to_string());
        self.output.push("  PLA          ; Restore ID".to_string());
        self.output.push("  CMP $F0".to_string());
        self.output
            .push("  BCS SndPlayEnd ; ID >= Count, Exit".to_string());

        // Calculate Pointer Address: $D101 + (ID * 2)
        self.output.push("  ASL          ; ID * 2".to_string());
        self.output.push("  TAX          ; X = ID * 2".to_string());

        // Read Track Pointer
        self.output.push("  LDA $D101, X ; Low".to_string());
        self.output.push("  STA $F0".to_string());
        self.output.push("  LDA $D102, X ; High".to_string());
        self.output.push("  STA $F1".to_string());

        // Read Channel Byte (First byte of track)
        self.output.push("  LDY #$00".to_string());
        self.output.push("  LDA ($F0), Y".to_string());
        self.output.push("  AND #$03     ; Mask to 0-3".to_string());

        // Calculate Channel Offset (Channel * 4) -> X
        self.output.push("  ASL".to_string());
        self.output.push("  ASL".to_string());
        self.output.push("  TAX".to_string());

        // Setup Channel State at $02E0 + X
        self.output.push("  LDA #$01".to_string());
        self.output.push("  STA $02E0, X ; Set Active".to_string());
        self.output.push("  LDA #$01".to_string());
        self.output
            .push("  STA $02E1, X ; Set Timer = 1 (Start immediately)".to_string());

        // Advance Pointer by 1 (skip Channel byte)
        self.output.push("  INC $F0".to_string());
        self.output.push("  BNE SndPtrInc".to_string());
        self.output.push("  INC $F1".to_string());
        self.output.push("SndPtrInc:".to_string());

        // Store Pointer
        self.output.push("  LDA $F0".to_string());
        self.output.push("  STA $02E2, X".to_string());
        self.output.push("  LDA $F1".to_string());
        self.output.push("  STA $02E3, X".to_string());

        self.output.push("SndPlayEnd:".to_string());
        self.output.push("  RTS".to_string());

        // Sound_Update (Called every frame)
        // Iterates through 3 channels (Offset 0, 4, 8)
        self.output.push("Sound_Update:".to_string());
        self.output.push("  PHA".to_string());
        self.output.push("  TXA".to_string());
        self.output.push("  PHA".to_string());
        self.output.push("  TYA".to_string());
        self.output.push("  PHA".to_string());

        // Channel 0
        self.output.push("  LDX #$00".to_string());
        self.output.push("  JSR SndChUpdate".to_string());
        // Channel 1
        self.output.push("  LDX #$04".to_string());
        self.output.push("  JSR SndChUpdate".to_string());
        // Channel 2
        self.output.push("  LDX #$08".to_string());
        self.output.push("  JSR SndChUpdate".to_string());

        self.output.push("  PLA".to_string());
        self.output.push("  TAY".to_string());
        self.output.push("  PLA".to_string());
        self.output.push("  TAX".to_string());
        self.output.push("  PLA".to_string());
        self.output.push("  RTS".to_string());

        // Subroutine: Update Channel X
        // Uses $F4-$F7 as scratchpad to avoid race condition with Sound_Play ($F0-$F1)
        self.output.push("SndChUpdate:".to_string());
        self.output.push("  LDA $02E0, X ; Active?".to_string());
        self.output.push("  BNE SndActive".to_string());
        self.output.push("  RTS".to_string());
        self.output.push("SndActive:".to_string());

        // Dec Timer
        self.output.push("  DEC $02E1, X".to_string());
        self.output.push("  BEQ SndTimerExpired".to_string());
        self.output.push("  RTS".to_string());
        self.output.push("SndTimerExpired:".to_string());

        // Fetch Next Note
        // Use $F4-$F5 for pointer
        self.output.push("  LDA $02E2, X ; Ptr Low".to_string());
        self.output.push("  STA $F4".to_string());
        self.output.push("  LDA $02E3, X ; Ptr High".to_string());
        self.output.push("  STA $F5".to_string());

        // Read Duration
        self.output.push("  LDY #$00".to_string());
        self.output.push("  LDA ($F4), Y".to_string());

        // If Duration is 0, End Track
        self.output.push("  CMP #$00".to_string());
        self.output.push("  BNE SndNextNote".to_string());
        self.output.push("  STA $02E0, X ; Deactivate".to_string());

        // Silence Channel
        self.output.push("  CPX #$00".to_string());
        self.output.push("  BEQ SilenceP1".to_string());
        self.output.push("  CPX #$04".to_string());
        self.output.push("  BEQ SilenceP2".to_string());
        self.output.push("  CPX #$08".to_string());
        self.output.push("  BEQ SilenceTri".to_string());
        self.output.push("  JMP SndChEnd".to_string());

        self.output.push("SilenceP1:".to_string());
        self.output.push("  LDA #$30".to_string());
        self.output.push("  STA $4000".to_string());
        self.output.push("  JMP SndChEnd".to_string());
        self.output.push("SilenceP2:".to_string());
        self.output.push("  LDA #$30".to_string());
        self.output.push("  STA $4004".to_string());
        self.output.push("  JMP SndChEnd".to_string());
        self.output.push("SilenceTri:".to_string());
        self.output.push("  LDA #$80".to_string());
        self.output.push("  STA $4008".to_string());
        self.output.push("  JMP SndChEnd".to_string());

        self.output.push("SndNextNote:".to_string());
        self.output.push("  STA $02E1, X ; Set Timer".to_string());

        // Advance Ptr
        self.output.push("  INC $F4".to_string());
        self.output.push("  BNE SndPtrInc2".to_string());
        self.output.push("  INC $F5".to_string());
        self.output.push("SndPtrInc2:".to_string());

        // Read Pitch Index
        self.output.push("  LDA ($F4), Y".to_string());

        // Lookup Period from Table at $D000
        // Table is 16-bit (2 bytes) per index
        self.output.push("  ASL          ; Index * 2".to_string());
        self.output.push("  TAY".to_string());
        self.output.push("  LDA $D000, Y ; Period Low".to_string());
        self.output.push("  STA $F6".to_string());
        self.output.push("  LDA $D001, Y ; Period High".to_string());
        self.output.push("  STA $F7".to_string());

        // Apply to Registers based on Channel (X)
        self.output.push("  CPX #$00".to_string());
        self.output.push("  BEQ PlayP1".to_string());
        self.output.push("  CPX #$04".to_string());
        self.output.push("  BEQ PlayP2".to_string());
        self.output.push("  CPX #$08".to_string());
        self.output.push("  BEQ PlayTri".to_string());
        self.output.push("  JMP SndAdvance".to_string());

        self.output.push("PlayP1:".to_string());
        self.output
            .push("  LDA #$9F     ; Duty 50%, Vol 15".to_string());
        self.output.push("  STA $4000".to_string());
        self.output.push("  LDA $F6".to_string());
        self.output.push("  STA $4002".to_string());
        self.output.push("  LDA $F7".to_string());
        self.output.push("  STA $4003".to_string());
        self.output.push("  JMP SndAdvance".to_string());

        self.output.push("PlayP2:".to_string());
        self.output.push("  LDA #$9F".to_string());
        self.output.push("  STA $4004".to_string());
        self.output.push("  LDA $F6".to_string());
        self.output.push("  STA $4006".to_string());
        self.output.push("  LDA $F7".to_string());
        self.output.push("  STA $4007".to_string());
        self.output.push("  JMP SndAdvance".to_string());

        self.output.push("PlayTri:".to_string());
        self.output
            .push("  LDA #$FF     ; Linear Counter On".to_string());
        self.output.push("  STA $4008".to_string());
        self.output.push("  LDA $F6".to_string());
        self.output.push("  STA $400A".to_string());
        self.output.push("  LDA $F7".to_string());
        self.output.push("  STA $400B".to_string());

        self.output.push("SndAdvance:".to_string());
        // Advance Ptr past Pitch
        self.output.push("  INC $F4".to_string());
        self.output.push("  BNE SndPtrInc3".to_string());
        self.output.push("  INC $F5".to_string());
        self.output.push("SndPtrInc3:".to_string());

        // Update Stored Pointer
        self.output.push("  LDA $F4".to_string());
        self.output.push("  STA $02E2, X".to_string());
        self.output.push("  LDA $F5".to_string());
        self.output.push("  STA $02E3, X".to_string());

        self.output.push("SndChEnd:".to_string());
        self.output.push("  RTS".to_string());
    }

    fn generate_math_helpers(&mut self) {
        self.output.push("; --- Math Helpers ---".to_string());

        // Math_Mul8: A * $00 -> A
        self.output.push("Math_Mul8:".to_string());
        self.output.push("  STA $01".to_string());
        self.output.push("  LDA #0".to_string());
        self.output.push("  LDX #8".to_string());
        self.output.push("Math_MulLoop:".to_string());
        self.output.push("  ASL".to_string());
        self.output.push("  ASL $01".to_string());
        self.output.push("  BCC Math_MulNoAdd".to_string());
        self.output.push("  CLC".to_string());
        self.output.push("  ADC $00".to_string());
        self.output.push("Math_MulNoAdd:".to_string());
        self.output.push("  DEX".to_string());
        self.output.push("  BNE Math_MulLoop".to_string());
        self.output.push("  RTS".to_string());

        // Math_Div8: A / $00 -> A
        self.output.push("Math_Div8:".to_string());
        self.output.push("  STA $02".to_string());
        self.output.push("  LDA #0".to_string());
        self.output.push("  STA $01".to_string());
        self.output.push("  LDX #8".to_string());
        self.output.push("Math_DivLoop:".to_string());
        self.output.push("  ASL $02".to_string());
        self.output.push("  ROL".to_string());
        self.output.push("  CMP $00".to_string());
        self.output.push("  BCC Math_DivSkip".to_string());
        self.output.push("  SBC $00".to_string());
        self.output.push("  INC $02".to_string());
        self.output.push("Math_DivSkip:".to_string());
        self.output.push("  DEX".to_string());
        self.output.push("  BNE Math_DivLoop".to_string());
        self.output.push("  LDA $02".to_string());
        self.output.push("  RTS".to_string());
    }

    fn generate_data_tables(&mut self, program: &Program) -> Result<(), String> {
        self.output.push("".to_string());
        self.output.push("; --- Data Tables ---".to_string());
        self.output.push(".ORG $FF00".to_string());

        let mut current_addr = 0xFF00;

        // InitDefaultRTI
        self.output
            .push("InitDefaultRTI: WORD DefaultRTI".to_string()); // $FF00
        current_addr += 2;

        for decl in &program.declarations {
            if let TopLevel::Interrupt(name, _) = decl {
                let upper = name.to_uppercase();
                if upper == "NMI" {
                    self.output.push(format!("InitNMI_{}: WORD {}", name, name));
                    current_addr += 2;
                } else if upper == "IRQ" {
                    self.output.push(format!("InitIRQ_{}: WORD {}", name, name));
                    current_addr += 2;
                }
                // For ON statement
                self.output.push(format!("Ptr_{}: WORD {}", name, name));
                self.data_table_offsets.insert(name.clone(), current_addr);
                current_addr += 2;
            }
            if let TopLevel::Sub(name, _, _) = decl {
                self.output.push(format!("Ptr_{}: WORD {}", name, name));
                self.data_table_offsets.insert(name.clone(), current_addr);
                current_addr += 2;
            }
        }
        self.output.push("".to_string());
        Ok(())
    }

    fn generate_vectors(&mut self, _program: &Program) -> Result<(), String> {
        self.output.push("".to_string());
        self.output.push(".ORG $FFFA".to_string());

        // NMI -> TrampolineNMI
        self.output.push("VecNMI: WORD TrampolineNMI".to_string());

        // RESET -> Startup (Fixed)
        self.output.push("VecReset: WORD Startup".to_string());

        // IRQ -> TrampolineIRQ
        self.output.push("VecIRQ: WORD TrampolineIRQ".to_string());

        self.output.push("".to_string()); // Ensure trailing newline

        Ok(())
    }

    fn allocate_memory(&mut self, program: &Program) -> Result<(), String> {
        // Simple allocation strategy: Linear allocation in Zero Page (0x00 - 0xFF)
        // or RAM (0x0200 - 0x07FF)

        // Reset pointer to start of user RAM (e.g., 0x0300 to avoid stack and system variables)
        // For 6502 NES, 0x00-0xFF is Zero Page (fast), 0x0100 is Stack. 0x0200 is OAM buffer usually.
        // Let's start at 0x0300 for global variables.
        self.ram_pointer = 0x0300;

        // Also prepare Data Table layout (ROM) starting at $FF00
        let mut data_table_addr = 0xFF00;
        // Reserve space for InitDefaultRTI
        data_table_addr += 2;

        for decl in &program.declarations {
            match decl {
                TopLevel::Dim(name, dtype) => {
                    // Assign address
                    self.symbol_table.assign_address(name, self.ram_pointer)?;
                    self.output
                        .push(format!("; {} @ ${:04X}", name, self.ram_pointer));

                    match dtype {
                        crate::compiler::ast::DataType::Byte
                        | crate::compiler::ast::DataType::Bool => {
                            self.ram_pointer += 1;
                        }
                        crate::compiler::ast::DataType::Word => {
                            self.ram_pointer += 2;
                        }
                    }
                }
                TopLevel::Sub(sub_name, params, _) => {
                    self.symbol_table.enter_scope(); // Enter Sub Scope

                    let mut sig_params = Vec::new();

                    for (param_name, param_type) in params {
                        // We need to define the parameter in the symbol table temporarily to assign address?
                        // `SemanticAnalyzer` defined it. But `CodeGenerator` receives `symbol_table`.
                        // `allocate_memory` creates a scope.
                        // We must DEFINE it here so `assign_address` works.
                        self.symbol_table.define(
                            param_name.clone(),
                            param_type.clone(),
                            SymbolKind::Param,
                        )?;

                        self.symbol_table
                            .assign_address(param_name, self.ram_pointer)?;
                        self.output.push(format!(
                            "; {}.{} @ ${:04X}",
                            sub_name, param_name, self.ram_pointer
                        ));

                        sig_params.push((self.ram_pointer, param_type.clone()));

                        match param_type {
                            crate::compiler::ast::DataType::Byte
                            | crate::compiler::ast::DataType::Bool => {
                                self.ram_pointer += 1;
                            }
                            crate::compiler::ast::DataType::Word => {
                                self.ram_pointer += 2;
                            }
                        }
                    }
                    // Store signature
                    self.sub_signatures.insert(sub_name.clone(), sig_params);

                    // Also allocate Data Table entry for Ptr_{SubName}
                    self.data_table_offsets
                        .insert(sub_name.clone(), data_table_addr);
                    data_table_addr += 2;

                    self.symbol_table.exit_scope();
                }
                TopLevel::Interrupt(name, _) => {
                    // Interrupts need Data Table entries
                    let upper = name.to_uppercase();
                    if upper == "NMI" {
                        // InitNMI_{name}
                        data_table_addr += 2;
                    } else if upper == "IRQ" {
                        // InitIRQ_{name}
                        data_table_addr += 2;
                    }
                    // Ptr_{name}
                    self.data_table_offsets
                        .insert(name.clone(), data_table_addr);
                    data_table_addr += 2;
                }
                _ => {}
            }
        }
        Ok(())
    }

    fn generate_top_level(&mut self, decl: &TopLevel) -> Result<(), String> {
        match decl {
            TopLevel::Sub(name, _params, body) => {
                self.output.push(format!("{}:", name));
                // Enter scope for parameters/locals
                self.symbol_table.enter_scope();
                self.generate_block(body)?;
                self.symbol_table.exit_scope();
                self.output.push("  RTS".to_string());
                self.output.push("".to_string()); // Newline for readability
            }
            TopLevel::Interrupt(name, body) => {
                self.output.push(format!("{}:", name));
                self.symbol_table.enter_scope();
                self.generate_block(body)?;
                self.symbol_table.exit_scope();
                self.output.push("  RTI".to_string());
                self.output.push("".to_string());
            }
            TopLevel::Const(_, _) => {
                // Constants are inlined usually, or we could emit equates?
                // For now, resolved at compile time if possible.
            }
            TopLevel::Dim(_, _) => {
                // Handled in allocation pass
            }
            TopLevel::Asm(lines) => {
                for line in lines {
                    self.output.push(format!("  {}", line));
                }
            }
        }
        Ok(())
    }

    fn generate_block(&mut self, statements: &[Statement]) -> Result<(), String> {
        for stmt in statements {
            self.generate_statement(stmt)?;
        }
        Ok(())
    }

    fn generate_statement(&mut self, stmt: &Statement) -> Result<(), String> {
        match stmt {
            Statement::Let(name, expr) => {
                if let Some(sym) = self.symbol_table.resolve(name) {
                    if let Some(addr) = sym.address {
                        match sym.data_type {
                            crate::compiler::ast::DataType::Word => {
                                // 16-bit assignment
                                // Note: SwissBASIC supports rudimentary 16-bit assignment for addresses.
                                // Complex 16-bit math is not fully implemented yet (expressions are 8-bit).
                                // We handle direct assignment of Literals and other WORD variables here.
                                match expr {
                                    Expression::Integer(val) => {
                                        // Valid 16-bit assignment
                                        let low = (val & 0xFF) as u8;
                                        let high = ((val >> 8) & 0xFF) as u8;
                                        self.output.push(format!("  LDA #${:02X}", low));
                                        self.output.push(format!("  STA ${:04X}", addr));
                                        self.output.push(format!("  LDA #${:02X}", high));
                                        self.output.push(format!("  STA ${:04X}", addr + 1));
                                    }
                                    Expression::Identifier(src_name) => {
                                        // Copy from another variable
                                        if let Some(src_sym) = self.symbol_table.resolve(src_name) {
                                            if let Some(src_addr) = src_sym.address {
                                                if src_sym.data_type
                                                    == crate::compiler::ast::DataType::Word
                                                {
                                                    // Copy Word
                                                    self.output
                                                        .push(format!("  LDA ${:04X}", src_addr));
                                                    self.output
                                                        .push(format!("  STA ${:04X}", addr));
                                                    self.output.push(format!(
                                                        "  LDA ${:04X}",
                                                        src_addr + 1
                                                    ));
                                                    self.output
                                                        .push(format!("  STA ${:04X}", addr + 1));
                                                } else {
                                                    // Copy Byte to Word (High = 0)
                                                    self.output
                                                        .push(format!("  LDA ${:04X}", src_addr));
                                                    self.output
                                                        .push(format!("  STA ${:04X}", addr));
                                                    self.output.push("  LDA #0".to_string());
                                                    self.output
                                                        .push(format!("  STA ${:04X}", addr + 1));
                                                }
                                            } else if src_sym.kind == SymbolKind::Constant {
                                                if let Some(val) = src_sym.value {
                                                    let low = (val & 0xFF) as u8;
                                                    let high = ((val >> 8) & 0xFF) as u8;
                                                    self.output
                                                        .push(format!("  LDA #${:02X}", low));
                                                    self.output
                                                        .push(format!("  STA ${:04X}", addr));
                                                    self.output
                                                        .push(format!("  LDA #${:02X}", high));
                                                    self.output
                                                        .push(format!("  STA ${:04X}", addr + 1));
                                                } else {
                                                    return Err(format!(
                                                        "Constant '{}' has no value assigned",
                                                        src_name
                                                    ));
                                                }
                                            } else {
                                                return Err(format!(
                                                    "Variable '{}' has no address",
                                                    src_name
                                                ));
                                            }
                                        } else {
                                            return Err(format!(
                                                "Undefined variable '{}'",
                                                src_name
                                            ));
                                        }
                                    }
                                    _ => {
                                        // Eval expression (8-bit) and assign to Word (Low)
                                        self.generate_expression(expr)?;
                                        self.output.push(format!("  STA ${:04X}", addr));
                                        self.output.push("  LDA #0".to_string());
                                        self.output.push(format!("  STA ${:04X}", addr + 1));
                                    }
                                }
                            }
                            _ => {
                                // Byte/Bool assignment
                                self.generate_expression(expr)?;
                                self.output.push(format!("  STA ${:04X} ; {}", addr, name));
                            }
                        }
                    } else {
                        return Err(format!(
                            "Variable '{}' has no address assigned (Locals not supported yet)",
                            name
                        ));
                    }
                } else {
                    return Err(format!("Undefined variable '{}'", name));
                }
            }
            Statement::Asm(lines) => {
                for line in lines {
                    self.output.push(format!("  {}", line));
                }
            }
            Statement::Poke(addr_expr, val_expr) => {
                // POKE(Address, Value)
                // 1. Calculate Value -> A
                self.generate_expression(val_expr)?;
                self.output.push("  PHA".to_string()); // Push Value

                // 2. Calculate Address
                // If Address is a Constant Integer or Constant Identifier, we can use absolute addressing directly.
                // If it is a variable or expression, we need indirect addressing.

                // Helper to check for constant address
                let const_addr = match addr_expr {
                    Expression::Integer(val) => Some(*val as u16),
                    Expression::Identifier(name) => self
                        .symbol_table
                        .resolve(name)
                        .and_then(|sym| sym.value.map(|val| val as u16)),
                    _ => None,
                };

                if let Some(addr) = const_addr {
                    self.output.push("  PLA".to_string()); // Restore Value to A
                    self.output.push(format!("  STA ${:04X}", addr));
                } else {
                    // Dynamic POKE using indirect Y addressing
                    // We use Zero Page locations $02-$03 as a temporary pointer.

                    self.output
                        .push("  ; Dynamic POKE (Indirect ZP)".to_string());

                    // The stack currently has: [Value] (from step 1 above)
                    // Because `generate_expression(val_expr)` was called, then `PHA`.

                    // Eval Address -> PtrLow ($02), PtrHigh ($03)
                    self.generate_address_expression(addr_expr)?;

                    // Prepare Y=0
                    self.output.push("  LDY #$00".to_string());

                    // Get Value from Stack
                    self.output.push("  PLA".to_string());

                    // Store Indirect
                    self.output.push("  STA ($02),y".to_string());
                }
            }
            Statement::If(condition, then_block, else_block) => {
                let else_label = self.new_label();
                let end_label = self.new_label();

                // 1. Evaluate Condition -> A
                self.generate_expression(condition)?;

                // 2. Check if false (0)
                self.output.push("  CMP #0".to_string());
                if else_block.is_some() {
                    self.output.push(format!("  BEQ {}", else_label));
                } else {
                    self.output.push(format!("  BEQ {}", end_label));
                }

                // 3. Generate Then Block
                self.generate_block(then_block)?;
                self.output.push(format!("  JMP {}", end_label));

                // 4. Generate Else Block
                if let Some(else_stmts) = else_block {
                    self.output.push(format!("{}:", else_label));
                    self.generate_block(else_stmts)?;
                }

                self.output.push(format!("{}:", end_label));
            }
            Statement::While(condition, body) => {
                let start_label = self.new_label();
                let end_label = self.new_label();

                self.output.push(format!("{}:", start_label));

                // 1. Evaluate Condition -> A
                self.generate_expression(condition)?;
                self.output.push("  CMP #0".to_string());
                self.output.push(format!("  BEQ {}", end_label));

                // 2. Body
                self.generate_block(body)?;

                // 3. Jump back
                self.output.push(format!("  JMP {}", start_label));
                self.output.push(format!("{}:", end_label));
            }
            Statement::DoWhile(body, condition) => {
                let start_label = self.new_label();
                self.output.push(format!("{}:", start_label));

                // 1. Body
                self.generate_block(body)?;

                // 2. Check Condition
                self.generate_expression(condition)?;
                self.output.push("  CMP #0".to_string());
                // If True (Not 0), Loop
                self.output.push(format!("  BNE {}", start_label));
            }
            Statement::For(var_name, start_expr, end_expr, step_expr, body) => {
                // FOR loop logic:
                // var = start
                // Loop:
                //   Positive Step: if var > end goto Exit
                //   Negative Step: if var < end goto Exit
                //   Body
                //   var = var + step
                //   Goto Loop
                // Exit:

                let loop_label = self.new_label();
                let exit_label = self.new_label();

                // Determine if step is negative constant
                let is_negative_step = match step_expr {
                    Some(Expression::Integer(val)) => *val < 0,
                    Some(Expression::Identifier(name)) => {
                        // Resolve constant
                        if let Some(sym) = self.symbol_table.resolve(name) {
                            if let Some(val) = sym.value {
                                val < 0
                            } else {
                                false
                            }
                        } else {
                            false
                        }
                    }
                    _ => false,
                };

                // 1. Initialize Variable
                // Let(var, start)
                self.generate_statement(&Statement::Let(var_name.clone(), start_expr.clone()))?;

                self.output.push(format!("{}:", loop_label));

                // 2. Check termination
                // We need to compare var with end_expr.
                // Load var -> A
                // Compare with end_expr

                // Eval var (Identifier)
                self.generate_expression(&Expression::Identifier(var_name.clone()))?;
                self.output.push("  PHA".to_string()); // Push Var

                // Eval end
                self.generate_expression(end_expr)?;
                self.output.push("  STA $00".to_string()); // Store End in Temp

                self.output.push("  PLA".to_string()); // Restore Var
                self.output.push("  CMP $00".to_string());

                let body_label = self.new_label();

                if is_negative_step {
                    // Negative Step: Loop while Var >= End
                    // If Var < End, Exit.
                    // CMP M: A < M -> Carry Clear (BCC).
                    self.output.push(format!("  BCC {}", exit_label)); // If A < End, Exit
                                                                       // Else (A >= End), continue to body
                } else {
                    // Positive Step (Default): Loop while Var <= End
                    // If Var > End, Exit.
                    // CMP M: A > M -> Carry Set (BCS) AND Not Equal.
                    self.output.push(format!("  BEQ {}", body_label)); // Equal -> Body
                    self.output.push(format!("  BCC {}", body_label)); // Less -> Body
                    self.output.push(format!("  JMP {}", exit_label)); // Greater -> Exit
                }

                self.output.push(format!("{}:", body_label));

                // 3. Body
                self.generate_block(body)?;

                // 4. Increment
                // var = var + step
                // Eval var
                self.generate_expression(&Expression::Identifier(var_name.clone()))?;
                self.output.push("  PHA".to_string());

                // Eval step
                if let Some(step) = step_expr {
                    self.generate_expression(step)?;
                } else {
                    self.output.push("  LDA #1".to_string());
                }
                self.output.push("  STA $00".to_string());
                self.output.push("  PLA".to_string());
                self.output.push("  CLC".to_string());
                self.output.push("  ADC $00".to_string());

                // Store back to var
                if let Some(sym) = self.symbol_table.resolve(var_name) {
                    if let Some(addr) = sym.address {
                        self.output.push(format!("  STA ${:04X}", addr));
                    }
                }

                if is_negative_step {
                    // Check for underflow (if Carry Set after ADDing negative number, it's NOT an underflow in 2's complement?)
                    // Wait, 6502 ADC with negative number:
                    // 5 + (-1 = 255). 5 + 255 = 260. Result 4. Carry Set (Wrap).
                    // 0 + (-1 = 255). 0 + 255 = 255. Result 255. Carry Clear (No Wrap).
                    // So if Carry Clear, we wrapped from 0 to 255.
                    // Therefore, if BCC, we should exit.
                    self.output.push(format!("  BCC {}", exit_label));
                }

                self.output.push(format!("  JMP {}", loop_label));
                self.output.push(format!("{}:", exit_label));
            }
            Statement::Return(expr) => {
                if let Some(e) = expr {
                    self.generate_expression(e)?;
                }
                self.output.push("  RTS".to_string());
            }
            Statement::Call(name, args) => {
                // Implementation Note: Code Generation for Function Calls
                // We rely on `sub_signatures` populated during the `allocate_memory` pass.
                // This allows us to know the memory addresses of parameters.
                //
                // "Temporary Solution" logic:
                // We assume arguments are provided in the correct order as defined in the SUB.
                // We do NOT perform rigorous type checking here beyond basic assignment logic.
                // 16-bit support for parameters is limited to Literals and direct Copy.

                // Get parameter info. Clone to avoid borrowing self during generation.
                let params = if let Some(p) = self.sub_signatures.get(name) {
                    p.clone()
                } else {
                    return Err(format!("Undefined sub '{}'", name));
                };

                if args.len() != params.len() {
                    return Err(format!(
                        "Call to '{}' has {} args, expected {}",
                        name,
                        args.len(),
                        params.len()
                    ));
                }

                self.generate_args(&params, args)?;
                self.output.push(format!("  JSR {}", name));
            }
            Statement::Print(_) => {
                self.output
                    .push("  ; PRINT not supported on NES target directly".to_string());
            }
            Statement::Comment(c) => {
                self.output.push(format!("  ; {}", c));
            }
            Statement::On(vector, routine) => {
                // ON <Vector> DO <Routine>
                // vector: String (NMI, IRQ)
                // routine: String (Sub name)

                let target_addr_low;
                let target_addr_high;

                let v_upper = vector.to_uppercase();
                if v_upper == "NMI" {
                    target_addr_low = "$03FA";
                    target_addr_high = "$03FB";
                } else if v_upper == "IRQ" {
                    target_addr_low = "$03FC";
                    target_addr_high = "$03FD";
                } else {
                    return Err(format!("Unknown interrupt vector '{}'", vector));
                }

                // Note: The routine should be a Sub name (which is a label).
                // We assume the routine exists (Validation should have happened).
                // CodeGen: Store Routine Address into RAM Vector.

                if let Some(addr) = self.data_table_offsets.get(routine) {
                    self.output.push(format!("  LDA ${:04X}", addr));
                    self.output.push(format!("  STA {}", target_addr_low));
                    self.output.push(format!("  LDA ${:04X}", addr + 1));
                    self.output.push(format!("  STA {}", target_addr_high));
                } else {
                    return Err(format!(
                        "Could not find data table entry for routine '{}'",
                        routine
                    ));
                }
            }
            Statement::PlaySfx(id_expr) => {
                // PlaySfx(id)
                self.generate_expression(id_expr)?;
                self.output.push("  JSR Sound_Play".to_string());
            }
        }
        Ok(())
    }

    fn generate_args(
        &mut self,
        params: &[(u16, DataType)],
        args: &[Expression],
    ) -> Result<(), String> {
        // Assign args to params
        for (i, expr) in args.iter().enumerate() {
            let (addr, dtype) = params[i].clone();

            // Generate code to evaluate expr and store to addr
            match dtype {
                crate::compiler::ast::DataType::Word => {
                    match expr {
                        Expression::Integer(val) => {
                            let low = (val & 0xFF) as u8;
                            let high = ((val >> 8) & 0xFF) as u8;
                            self.output.push(format!("  LDA #${:02X}", low));
                            self.output.push(format!("  STA ${:04X}", addr));
                            self.output.push(format!("  LDA #${:02X}", high));
                            self.output.push(format!("  STA ${:04X}", addr + 1));
                        }
                        Expression::Identifier(src) => {
                            // Copy
                            if let Some(sym) = self.symbol_table.resolve(src) {
                                if let Some(src_addr) = sym.address {
                                    // Check type... assume Word copy
                                    self.output.push(format!("  LDA ${:04X}", src_addr));
                                    self.output.push(format!("  STA ${:04X}", addr));
                                    self.output.push(format!("  LDA ${:04X}", src_addr + 1));
                                    self.output.push(format!("  STA ${:04X}", addr + 1));
                                } else if sym.kind == SymbolKind::Constant {
                                    if let Some(val) = sym.value {
                                        let low = (val & 0xFF) as u8;
                                        let high = ((val >> 8) & 0xFF) as u8;
                                        self.output.push(format!("  LDA #${:02X}", low));
                                        self.output.push(format!("  STA ${:04X}", addr));
                                        self.output.push(format!("  LDA #${:02X}", high));
                                        self.output.push(format!("  STA ${:04X}", addr + 1));
                                    } else {
                                        return Err(format!(
                                            "Constant '{}' has no value assigned",
                                            src
                                        ));
                                    }
                                } else {
                                    return Err(format!("Variable '{}' has no address", src));
                                }
                            } else {
                                return Err(format!("Undefined var {}", src));
                            }
                        }
                        _ => {
                            self.generate_expression(expr)?;
                            self.output.push(format!("  STA ${:04X}", addr));
                            self.output.push("  LDA #0".to_string());
                            self.output.push(format!("  STA ${:04X}", addr + 1));
                        }
                    }
                }
                _ => {
                    self.generate_expression(expr)?;
                    self.output.push(format!("  STA ${:04X}", addr));
                }
            }
        }
        Ok(())
    }

    fn generate_address_expression(&mut self, expr: &Expression) -> Result<(), String> {
        // Evaluate expression and store result in $02 (Low) and $03 (High)
        match expr {
            Expression::Integer(val) => {
                let low = (val & 0xFF) as u8;
                let high = ((val >> 8) & 0xFF) as u8;
                self.output.push(format!("  LDA #${:02X}", low));
                self.output.push("  STA $02".to_string());
                self.output.push(format!("  LDA #${:02X}", high));
                self.output.push("  STA $03".to_string());
            }
            Expression::Identifier(name) => {
                if let Some(sym) = self.symbol_table.resolve(name) {
                    if let Some(addr) = sym.address {
                        match sym.data_type {
                            crate::compiler::ast::DataType::Word => {
                                self.output.push(format!("  LDA ${:04X}", addr));
                                self.output.push("  STA $02".to_string());
                                self.output.push(format!("  LDA ${:04X}", addr + 1));
                                self.output.push("  STA $03".to_string());
                            }
                            _ => {
                                // Byte to Word
                                self.output.push(format!("  LDA ${:04X}", addr));
                                self.output.push("  STA $02".to_string());
                                self.output.push("  LDA #0".to_string());
                                self.output.push("  STA $03".to_string());
                            }
                        }
                    } else if sym.kind == SymbolKind::Constant {
                        // Should be handled by caller usually, but if dynamic use:
                        if let Some(val) = sym.value {
                            let low = (val & 0xFF) as u8;
                            let high = ((val >> 8) & 0xFF) as u8;
                            self.output.push(format!("  LDA #${:02X}", low));
                            self.output.push("  STA $02".to_string());
                            self.output.push(format!("  LDA #${:02X}", high));
                            self.output.push("  STA $03".to_string());
                        }
                    } else {
                        return Err(format!("Variable '{}' has no address", name));
                    }
                } else {
                    return Err(format!("Undefined variable '{}'", name));
                }
            }
            _ => {
                // Fallback to 8-bit evaluation
                self.generate_expression(expr)?;
                self.output.push("  STA $02".to_string());
                self.output.push("  LDA #0".to_string());
                self.output.push("  STA $03".to_string());
            }
        }
        Ok(())
    }

    fn generate_expression(&mut self, expr: &Expression) -> Result<(), String> {
        // Result should be left in Accumulator (A)
        match expr {
            Expression::Integer(val) => {
                // Load immediate
                if *val > 255 || *val < -128 {
                    // For now, only 8-bit immediate values are supported
                    return Err(format!(
                        "Integer literal {} exceeds 8-bit limit (0-255)",
                        val
                    ));
                }
                let byte_val = (val & 0xFF) as u8;
                self.output.push(format!("  LDA #${:02X}", byte_val));
            }
            Expression::StringLiteral(_) => {
                // String literals are not supported in general expressions yet (only in Print/Data?)
                return Err("String literals not supported in expressions".to_string());
            }
            Expression::Identifier(name) => {
                if let Some(sym) = self.symbol_table.resolve(name) {
                    if let Some(addr) = sym.address {
                        self.output.push(format!("  LDA ${:04X} ; {}", addr, name));
                    } else if sym.kind == SymbolKind::Constant {
                        if let Some(val) = sym.value {
                            let byte_val = (val & 0xFF) as u8;
                            self.output.push(format!("  LDA #${:02X}", byte_val));
                        } else {
                            return Err(format!("Constant '{}' has no value assigned", name));
                        }
                    } else {
                        return Err(format!("Variable '{}' has no address", name));
                    }
                } else {
                    return Err(format!("Undefined variable '{}'", name));
                }
            }
            Expression::Peek(addr_expr) => {
                // PEEK(Address) -> A
                // We need to support dynamic address if possible, but 6502 needs absolute or indirect.
                // If constant, absolute.
                let const_addr = match &**addr_expr {
                    Expression::Integer(val) => Some(*val as u16),
                    Expression::Identifier(name) => self
                        .symbol_table
                        .resolve(name)
                        .and_then(|sym| sym.value.map(|val| val as u16)),
                    _ => None,
                };

                if let Some(addr) = const_addr {
                    self.output.push(format!("  LDA ${:04X}", addr));
                } else {
                    // Dynamic PEEK using indirect Y addressing
                    // We use Zero Page locations $02-$03 as a temporary pointer.
                    self.generate_address_expression(addr_expr)?;
                    self.output.push("  LDY #$00".to_string());
                    self.output.push("  LDA ($02),y".to_string());
                }
            }
            Expression::FunctionCall(name, args) => {
                // Implementation for Function Calls (Same as Call but used in expression)
                let params = if let Some(p) = self.sub_signatures.get(name) {
                    p.clone()
                } else {
                    return Err(format!("Undefined sub '{}'", name));
                };

                if args.len() != params.len() {
                    return Err(format!(
                        "Call to '{}' has {} args, expected {}",
                        name,
                        args.len(),
                        params.len()
                    ));
                }

                self.generate_args(&params, args)?;
                self.output.push(format!("  JSR {}", name));
                // Result is expected in A. If SUB doesn't return anything explicit, it's A.
            }
            Expression::UnaryOp(op, operand) => {
                self.generate_expression(operand)?;
                match op {
                    UnaryOperator::Negate => {
                        // Negate A (2's complement): EOR #$FF + 1, or 0 - A
                        self.output.push("  EOR #$FF".to_string());
                        self.output.push("  CLC".to_string());
                        self.output.push("  ADC #01".to_string());
                    }
                    UnaryOperator::Not => {
                        // Logical NOT: If 0 -> 1, If != 0 -> 0
                        let false_label = self.new_label();
                        let done_label = self.new_label();
                        self.output.push("  CMP #0".to_string());
                        self.output.push(format!("  BNE {}", false_label));
                        self.output.push("  LDA #1".to_string()); // Was 0, now 1
                        self.output.push(format!("  JMP {}", done_label));
                        self.output.push(format!("{}:", false_label));
                        self.output.push("  LDA #0".to_string()); // Was !=0, now 0
                        self.output.push(format!("{}:", done_label));
                    }
                }
            }
            Expression::BinaryOp(left, op, right) => {
                self.generate_expression(left)?;
                self.output.push("  PHA".to_string());
                self.generate_expression(right)?;
                self.output.push("  STA $00".to_string());
                self.output.push("  PLA".to_string());

                match op {
                    BinaryOperator::Add => {
                        self.output.push("  CLC".to_string());
                        self.output.push("  ADC $00".to_string());
                    }
                    BinaryOperator::Subtract => {
                        self.output.push("  SEC".to_string());
                        self.output.push("  SBC $00".to_string());
                    }
                    BinaryOperator::Multiply => {
                        self.output.push("  JSR Math_Mul8".to_string());
                    }
                    BinaryOperator::Divide => {
                        // Divisor is in $00. Dividend in A.
                        // Check div by zero?
                        self.output.push("  JSR Math_Div8".to_string());
                    }
                    BinaryOperator::And => {
                        self.output.push("  AND $00".to_string());
                    }
                    BinaryOperator::Or => {
                        self.output.push("  ORA $00".to_string());
                    }
                    BinaryOperator::Equal => {
                        // CMP returns Z=1 if equal.
                        // We want A=1 if equal, A=0 if not.
                        let true_lbl = self.new_label();
                        let end_lbl = self.new_label();
                        self.output.push("  CMP $00".to_string());
                        self.output.push(format!("  BEQ {}", true_lbl));
                        self.output.push("  LDA #0".to_string());
                        self.output.push(format!("  JMP {}", end_lbl));
                        self.output.push(format!("{}:", true_lbl));
                        self.output.push("  LDA #1".to_string());
                        self.output.push(format!("{}:", end_lbl));
                    }
                    BinaryOperator::NotEqual => {
                        let true_lbl = self.new_label();
                        let end_lbl = self.new_label();
                        self.output.push("  CMP $00".to_string());
                        self.output.push(format!("  BNE {}", true_lbl)); // Not Equal
                        self.output.push("  LDA #0".to_string());
                        self.output.push(format!("  JMP {}", end_lbl));
                        self.output.push(format!("{}:", true_lbl));
                        self.output.push("  LDA #1".to_string());
                        self.output.push(format!("{}:", end_lbl));
                    }
                    BinaryOperator::LessThan => {
                        // A < M -> BCC (Carry Clear)
                        let true_lbl = self.new_label();
                        let end_lbl = self.new_label();
                        self.output.push("  CMP $00".to_string());
                        self.output.push(format!("  BCC {}", true_lbl));
                        self.output.push("  LDA #0".to_string());
                        self.output.push(format!("  JMP {}", end_lbl));
                        self.output.push(format!("{}:", true_lbl));
                        self.output.push("  LDA #1".to_string());
                        self.output.push(format!("{}:", end_lbl));
                    }
                    BinaryOperator::GreaterThan => {
                        // A > M
                        // CMP: A - M
                        // if A <= M, Carry Clear or Z set?
                        // BCS (Carry Set) if A >= M.
                        // BEQ (Zero Set) if A == M.
                        // So A > M is BCS AND BNE.
                        // logic:
                        // CMP M
                        // BEQ False (Equal)
                        // BCC False (Less)
                        // BCS True (Greater)

                        let true_lbl = self.new_label();
                        let false_lbl = self.new_label();
                        let end_lbl = self.new_label();

                        self.output.push("  CMP $00".to_string());
                        self.output.push(format!("  BEQ {}", false_lbl));
                        self.output.push(format!("  BCC {}", false_lbl));
                        self.output.push(format!("  BCS {}", true_lbl)); // Should be reached if not Eq and not Less

                        self.output.push(format!("{}:", false_lbl));
                        self.output.push("  LDA #0".to_string());
                        self.output.push(format!("  JMP {}", end_lbl));

                        self.output.push(format!("{}:", true_lbl));
                        self.output.push("  LDA #1".to_string());
                        self.output.push(format!("{}:", end_lbl));
                    }
                    BinaryOperator::LessThanOrEqual => {
                        // A <= M
                        // Inverse of > (Greater Than)
                        // CMP M
                        // BEQ True
                        // BCC True
                        // BCS False (Greater)

                        let true_lbl = self.new_label();
                        let end_lbl = self.new_label();

                        self.output.push("  CMP $00".to_string());
                        self.output.push(format!("  BEQ {}", true_lbl));
                        self.output.push(format!("  BCC {}", true_lbl));
                        self.output.push("  LDA #0".to_string()); // Greater
                        self.output.push(format!("  JMP {}", end_lbl));

                        self.output.push(format!("{}:", true_lbl));
                        self.output.push("  LDA #1".to_string());
                        self.output.push(format!("{}:", end_lbl));
                    }
                    BinaryOperator::GreaterThanOrEqual => {
                        // A >= M
                        // BCS (Carry Set) covers >=
                        let true_lbl = self.new_label();
                        let end_lbl = self.new_label();

                        self.output.push("  CMP $00".to_string());
                        self.output.push(format!("  BCS {}", true_lbl));
                        self.output.push("  LDA #0".to_string());
                        self.output.push(format!("  JMP {}", end_lbl));
                        self.output.push(format!("{}:", true_lbl));
                        self.output.push("  LDA #1".to_string());
                        self.output.push(format!("{}:", end_lbl));
                    }
                }
            }
        }
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::compiler::ast::DataType;
    use crate::compiler::symbol_table::SymbolKind;

    #[test]
    fn test_codegen_var_assignment() {
        let mut st = SymbolTable::new();
        // Register symbols that analysis phase would have caught
        st.define("x".to_string(), DataType::Byte, SymbolKind::Variable)
            .unwrap();
        st.define("y".to_string(), DataType::Byte, SymbolKind::Variable)
            .unwrap();

        let program = Program {
            declarations: vec![
                TopLevel::Dim("x".to_string(), DataType::Byte),
                TopLevel::Dim("y".to_string(), DataType::Byte),
                TopLevel::Sub(
                    "Main".to_string(),
                    vec![],
                    vec![
                        Statement::Let("x".to_string(), Expression::Integer(10)),
                        Statement::Let(
                            "y".to_string(),
                            Expression::BinaryOp(
                                Box::new(Expression::Identifier("x".to_string())),
                                BinaryOperator::Add,
                                Box::new(Expression::Integer(5)),
                            ),
                        ),
                    ],
                ),
            ],
        };

        let mut cg = CodeGenerator::new(st);
        let code = cg.generate(&program).expect("Codegen failed");

        // Basic check of output
        assert!(code.iter().any(|line| line.contains("x @ $0300")));
        assert!(code.iter().any(|line| line.contains("y @ $0301")));
        assert!(code.iter().any(|line| line.contains("LDA #$0A"))); // 10
        assert!(code.iter().any(|line| line.contains("STA $0300")));
    }

    #[test]
    fn test_codegen_nested_expression() {
        // Test (1 + 2) + 3
        let mut st = SymbolTable::new();
        st.define("z".to_string(), DataType::Byte, SymbolKind::Variable)
            .unwrap();

        let program = Program {
            declarations: vec![
                TopLevel::Dim("z".to_string(), DataType::Byte),
                TopLevel::Sub(
                    "Main".to_string(),
                    vec![],
                    vec![Statement::Let(
                        "z".to_string(),
                        Expression::BinaryOp(
                            Box::new(Expression::BinaryOp(
                                Box::new(Expression::Integer(1)),
                                BinaryOperator::Add,
                                Box::new(Expression::Integer(2)),
                            )),
                            BinaryOperator::Add,
                            Box::new(Expression::Integer(3)),
                        ),
                    )],
                ),
            ],
        };

        let mut cg = CodeGenerator::new(st);
        let code = cg.generate(&program).expect("Codegen failed");

        assert!(code.iter().any(|line| line.contains("STA $00")));
        assert!(code.iter().any(|line| line.contains("PHA")));
        assert!(code.iter().any(|line| line.contains("PLA")));
    }
}
